
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Eve</title>
  <style>
    :root{
      --width:960px; --height:600px;
      --bg: #000000;
      --panel: #1a1a1a;
      --panel-2: #2a2a2a;
      --border: #4a2a2a;
      --muted: #888888;
      --accent: #e0e0e0;
      --danger:#e87d7d;
      --highlight: #8a3a3a;
      --editor-select: #8a3a3a;
    }
    
    html,body{
        height:100%;
        margin:0;
        font-family:"Dotum", "돋움", "Gulim", "Apple SD Gothic Neo", sans-serif; 
        background:var(--bg); 
        color:var(--accent); 
        display:flex; 
        align-items:center; 
        justify-content:center;
        font-size: 14px; 
        line-height: 1.5;
    }
    .wrap{width:min(100%,var(--width));}
    
    body[data-mode="admin"]{align-items:flex-start; justify-content:flex-start;}
    body[data-mode="admin"] .wrap{max-width:none;}

    .btn{
        background:var(--panel-2);
        border:1px solid var(--border);
        padding:6px 12px;
        border-radius:0;
        color:var(--accent);
        cursor:pointer;
        font-size:14px;
        font-family: inherit;
    }
    .btn:hover{
        background:var(--panel);
        border-color: var(--highlight);
    }
    .btn.primary{
        background:var(--highlight);
        border-color:var(--highlight);
        color:var(--accent);
        font-weight:bold;
    }
    .btn.primary:hover{
        background:var(--accent);
        border-color:var(--accent);
        color: var(--bg);
    }
    .btn.ghost{
        background:transparent;
        border:1px solid var(--border);
        color:var(--accent);
    }
    .btn.ghost:hover{
        background:var(--panel-2);
        border-color: var(--highlight);
    }
    .btn.ghost.danger{
        color: var(--danger);
        border-color: var(--border);
    }
    .btn.ghost.danger:hover{
        background: var(--danger);
        color: var(--panel);
        border-color: var(--danger);
    }
    .btn.btn-sm {
        padding: 3px 8px;
        font-size: 12px;
    }


    .game{position:relative;width:var(--width);height:var(--height);overflow:hidden;border:1px solid var(--border);background:#000;box-shadow:none;}
    .scene-bg{position:absolute;inset:0;background-size:cover;background-position:center;filter:none;}
    .hotspot{position:absolute;cursor:crosshair;}

    .popup{
        position:absolute;
        display:none;
        z-index:60;
        color:var(--accent);
    }
    
    .popup:not(#inspectPopup){
        left:50%;
        top:50%;
        transform:translate(-50%,-50%);
        min-width:320px;
        background:var(--panel);
        padding:12px;
        border-radius:0;
        border:1px solid var(--border);
    }
    
    #inspectPopup{
        left: 12px;
        right: 12px;
        bottom: 12px;
        width: auto;
        height: 150px;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px;
        border: 1px solid var(--border);
        border-radius:0;
        flex-direction: row;
        align-items: flex-start;
        gap: 15px;
        box-sizing: border-box;
    }
    
    .popup.show{display:flex}
    
    #inspectPopup h3{
        display: none;
    }
    
    .popup:not(#inspectPopup) h3{
        margin:0;
        font-size:16px;
        color:var(--accent);
        border-bottom:1px solid var(--border);
        padding-bottom:6px;
        margin-bottom:10px;
    }
    
    .popup:not(#inspectPopup) p{margin:10px 0;color:var(--accent); white-space: pre-wrap; font-size: 14px;}
    
    #inspectPopup #popupImg {
        width: 120px;
        height: 120px;
        object-fit: cover;
        margin: 0;
        border: 1px solid var(--border);
        flex-shrink: 0;
    }
    
    .popup-text-container {
        flex-grow: 1;
        position: relative;
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    #inspectPopup p{
        flex-grow: 1;
        margin: 0;
        font-size: 16px;
        line-height: 1.6;
        white-space: pre-wrap;
        color: var(--accent);
        margin-block-start: 0;
        margin-block-end: 0;
        overflow: hidden;
        cursor: pointer;
    }
    
    #popupHeader {
        margin-bottom: 5px;
    }
    #popupHotspotLabel {
        font-weight: bold;
        color: var(--accent);
        font-size: 16px;
    }
    
    #popupContinue {
        position: absolute;
        bottom: 0px;
        right: 5px;
        color: var(--accent);
        font-size: 18px;
        cursor: pointer;
        animation: blink 1.5s step-end infinite;
    }
    
    @keyframes blink {
        50% { opacity: 0; }
    }
    
    .choice-popup {
        position: absolute;
        bottom: 167px;
        right: 12px;
        width: 180px;
        background: var(--panel);
        border: 1px solid var(--border);
        display: none;
        flex-direction: column;
        z-index: 70;
    }
    .choice-popup.show {
        display: flex;
    }
    .choice-popup .btn {
        background: transparent;
        border: none;
        border-bottom: 1px solid var(--border);
        padding: 10px 12px;
        text-align: left;
        color: var(--muted);
        width: 100%;
        box-sizing: border-box;
        border-radius: 0;
        font-size: 14px;
        display: none;
    }
    .choice-popup .btn:last-child {
        border-bottom: none;
    }
    .choice-popup .btn.ghost {
        border-top: 1px solid var(--border);
        margin-top: -1px;
    }
    .choice-popup .btn:hover {
        background: var(--highlight);
        color: var(--accent);
        border-color: var(--highlight);
    }
    .choice-popup .btn[style*="display: inline-block"] {
        display: block !important;
    }


    .inventory{
        position:absolute;
        right: 12px;
        top: 70px;
        bottom: auto;
        display:flex;
        align-items:flex-end;
        flex-direction: column;
        gap:6px;
        z-index:70;
    }
    .inv-panel{
        margin-left:0;
        display:flex;
        flex-direction: column;
        gap:4px;
        padding:4px;
        border-radius:0;
        background:var(--panel);
        border:1px solid var(--border);
        max-height: 212px;
        overflow-y: auto;
    }
    .inv-slot{
        width:48px;
        height:48px;
        border-radius:0;
        border:1px solid var(--border);
        display:flex;
        align-items:center;
        justify-content:center;
        background:var(--panel-2);
        cursor:pointer;
        position:relative;
    }
    .inv-slot img{max-width:36px;max-height:36px}
    .inv-slot.selected{outline:2px solid var(--highlight);outline-offset:-1px;}

    .admin-mode{display:none;width:100%;max-width:100%;padding:12px;background:var(--bg);border-radius:0;max-height:100vh;overflow:auto}
    .admin-grid{
        display:grid;
        grid-template-columns:320px 1fr 320px;
        gap:12px;
        width:100%;
        height: 88vh; /* Fixed height */
        min-height: 600px;
    }
    
    .admin-panel-container-left {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    
    .admin-panel-container-right { 
        display: flex; 
        flex-direction: column; 
        height: 100%;
    }
    
    .admin-panel{
        background:var(--panel);
        padding:10px;
        border-radius:0;
        border:1px solid var(--border);
        height:100%;
        min-height:400px;
        display:flex;
        flex-direction:column; 
        box-sizing: border-box;
    }
    
    .admin-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border);
        margin-bottom: 8px;
    }
    .admin-panel-header h2 {
        margin: 0;
        padding-bottom: 6px;
        border-bottom: none;
        color:var(--accent);
        font-size:18px;
    }
    .admin-panel-header .header-buttons {
        padding-bottom: 6px;
    }

    .admin-panel h2{
        margin:0 0 8px 0;
        color:var(--accent);
        font-size:18px;
        border-bottom:1px solid var(--border);
        padding-bottom:6px;
    }
    .admin-panel h3{
        font-size:16px;
        color:var(--accent); 
        margin:0 0 6px 0;
    } 
    
    .admin-panel-content{
        flex-grow:1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow-y: auto; /* Content (form + list) scrolls */
        padding-right: 5px;
    }
    .admin-panel-list{
        margin-top:8px;
        flex-shrink: 0; /* List takes its natural height */
    }

    /* Hotspot list is special case, it fills remaining space */
    #hotspot-list-container.admin-panel-list {
         flex-grow: 1;
         min-height: 0;
         overflow-y: auto;
         flex-shrink: 1;
    }
    
    /* Config tab content also scrolls */
    .tab-content[data-tab-content="config"] .admin-panel-content {
        overflow-y: auto;
    }


    .form-button-group {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        flex-wrap: wrap;
        justify-content: flex-end; /* Align buttons to the right */
    }
    
    .panel-button-bar {
        flex-shrink: 0;
        margin-bottom: 8px;
        text-align: right;
    }

    .drag-handle { margin-right: 8px; color: #777; cursor: move; }

    .admin-panel-list-item{
        padding: 6px; /* Adjusted padding */
        border-bottom:1px solid var(--panel-2);
        display:flex;
        justify-content:space-between;
        align-items:center;
        font-size:14px;
    }
    
    .admin-panel-list-item .item-label {
        flex-grow: 1;
        margin-left: 4px;
        cursor: pointer;
        line-height: 1.4; /* Added line-height */
    }
    .item-id-code { /* New class for the code tag */
        font-size: 12px;
        color: var(--muted);
    }
    
    .admin-panel-list-item .item-buttons {
        flex-shrink: 0;
        display: flex;
        gap: 6px;
    }
    
    .form-group{margin-bottom:8px}
    .form-group label{display:block;margin-bottom:4px;color:var(--muted);font-size:14px;}
    .form-group input,.form-group textarea,.form-group select{
        width:100%;
        box-sizing:border-box;
        background:var(--panel-2);
        border:1px solid var(--border);
        padding:6px;
        border-radius:0;
        color:var(--accent);
        font-size:14px;
        font-family: inherit;
    }
    .form-group input:focus,.form-group textarea:focus,.form-group select:focus {border-color: var(--highlight); outline: none;}
    .form-group input[type="range"] { padding: 0; }
    
    .form-group.sub-group { display: none; margin-left: 10px; border-left: 2px solid #555; padding-left: 10px; }
    .form-group.sub-group.show { display: block; }

    
    #hotspot-editor-preview{
        position:relative;
        width:100%;
        max-width: var(--width); 
        aspect-ratio: 960 / 600; 
        background:#111 center/cover;
        border-radius:0;
        border:1px solid var(--border);
        margin: 0 auto;
    }
    .editor-hotspot{position:absolute;border:1px dashed var(--accent);background:rgba(240, 240, 240, 0.1);box-sizing:border-box}
    .editor-hotspot.selected{outline:2px solid var(--editor-select);outline-offset:-2px;}

    .handle{position:absolute;width:8px;height:8px;border-radius:0;background:var(--editor-select);border:1px solid #000;box-sizing:border-box}
    .handle.br{right:-4px;bottom:-4px;cursor:se-resize}
    
    .admin-main {
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Make this whole column scroll */
    }

    #hotspot-form-container.admin-panel {
        height: auto; /* Override height: 100% */
        min-height: 0; /* Override min-height: 400px */
        max-height: 70vh; /* Set a max height relative to viewport */
        overflow-y: auto; /* Make the panel scroll if content overflows */
        flex-shrink: 0; /* Prevent shrinking in flex context */
    }

    .login-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:200}
    .login-modal-content{
        background:var(--panel);
        padding:15px;
        border-radius:0;
        width:300px;
        border:1px solid var(--border);
        color:var(--accent);
    }

    .hud{
        position:absolute;
        left:12px;
        top:12px;
        padding:4px 8px;
        background:var(--panel);
        border-radius:0;
        border:1px solid var(--border);
        font-size:14px;
        z-index:75;
    }

    .game-mode { display: none; }
    .admin-mode { display: none; }
    
    .player-view-container {
        display: none;
        flex-direction: column;
        width: min(100%, var(--width));
    }
    body[data-mode="player"] .player-view-container {
        display: flex;
    }
    body[data-mode="player"] .game-mode{
        display:block;
        width: 100%;
    }
    body[data-mode="admin"] .admin-mode{display:block;padding:12px;}

    @media(max-width:1200px){.admin-grid{grid-template-columns:1fr}}
    
    
    /* Tab Styles for Admin Panels */
    .tab-headers {
        display: flex;
        border-bottom: 1px solid var(--border);
        margin-bottom: 10px;
        flex-shrink: 0;
    }
    .tab-btn {
        background: transparent;
        border: none;
        padding: 8px 14px;
        cursor: pointer;
        color: var(--muted);
        font-size: 15px;
        border-bottom: 2px solid transparent;
        margin-bottom: -1px;
    }
    .tab-btn.active {
        color: var(--accent);
        border-bottom-color: var(--highlight);
        font-weight: bold;
    }
    .tab-btn:hover:not(.active) {
        color: var(--accent);
        border-bottom-color: var(--panel-2);
    }
    .tab-content-wrapper {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
    }
    .tab-content {
        display: none;
        flex-grow: 1;
        flex-direction: column;
        min-height: 0;
    }
    .tab-content.active {
        display: flex;
    }
    
    .tab-content .admin-panel-content {
         flex-grow: 1;
         display: flex;
         flex-direction: column;
         min-height: 0;
    }
    
    /* Select Mode Toggle */
    .admin-panel-list-item .item-select-cb {
        display: none;
        margin-right: 8px;
        vertical-align: middle;
    }
    .admin-panel-list.select-mode .item-select-cb {
        display: inline-block;
    }
    #hotspot-list-container.select-mode .item-select-cb {
        display: inline-block;
    }


    #bgm-controls {
        z-index: 100; 
        display: none;
        margin-bottom: 10px;
    }
    
    body[data-mode="player"] #bgm-controls {
        display: none;
    }

    @media (min-width: 961px) {
        body[data-mode="player"] #bgm-controls {
            display: block;
        }
    }
    
    .hud-hp-container {
        position:absolute; 
        top:12px; 
        right:12px; 
        z-index: 75; 
        width: 150px; 
        background: var(--panel); 
        border: 1px solid var(--border); 
        padding: 4px; 
        font-size: 14px;
        color: var(--accent);
    }
    .hp-bar-outer {
        background: #111; 
        border: 1px solid var(--border); 
        height: 10px; 
        padding: 1px;
    }
    #hp-bar-inner {
        background: var(--danger); 
        height: 100%; 
        width: 100%; 
        transition: width 0.3s ease;
    }
    
    #item-info-healing-details {
        font-size: 14px; 
        color: var(--muted); 
        margin-bottom: 15px; 
        display: none;
    }
    
    ::-webkit-scrollbar {
      display: none;
    }
    body, .admin-panel-list, .admin-mode, .inv-panel, .admin-panel-content, .admin-main {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .admin-mode {
        overflow: auto;
    }
    .admin-panel-list {
        overflow-y: auto;
    }
    .admin-panel-content {
        overflow-y: auto;
    }
    .admin-main {
        overflow-y: auto;
    }
    
    /* Re-enable scroll on hotspot list */
    #hotspot-list-container.admin-panel-list {
        overflow-y: auto;
    }
</style>
</head>
<body data-mode="">
  
  <audio id="bgm-audio" loop></audio>
  
  <div class="player-view-container">
    <div id="bgm-controls">
      <button id="bgm-play-pause" class="btn">Play</button>
      <input id="bgm-volume" type="range" min="0" max="1" step="0.01" value="0.5" style="vertical-align: middle; margin-left: 8px; width: 100px;">
    </div>

    <div class="wrap game-mode">
      <div class="game" id="game">
        <div class="scene-bg" id="sceneBg"></div>
        <div id="hotspotLayer" style="position:absolute;inset:0;z-index:40;"></div>

        <div class="popup" id="inspectPopup" role="dialog" aria-modal="true">
          <div class="popup-text-container">
              <div id="popupHeader">
                  <span id="popupHotspotLabel"></span>
              </div>
              <h3 id="popupTitle" style="display:none;">조사</h3>
              <p id="popupText">내용</p>
              <div id="popupContinue" style="display:none;">▶</div>
          </div>
        </div>
        
        <div class="choice-popup" id="choicePopup">
          <button class="btn" id="btnInspect">조사</button>
          <button class="btn" id="btnUseItem" style="display:none">아이템 사용</button>
          <button class="btn" id="btnMoveFromSuccess" style="display:none;">이동</button>
        </div>

        <div class="hud">
          Scene: <span id="hudScene">-</span><br>
          Player ID: <code id="hudUserId">local_player</code>
          <div style="margin-top:6px;display:flex;gap:6px"><button class="btn ghost btn-sm" id="btn-change-player">Player</button><button class="btn ghost btn-sm" id="btn-admin-login">Admin</button></div>
        </div>
        
        <div class="hud-hp-container">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
              <span>HP</span>
              <span><span id="hp-value">100</span> / <span id="hp-max">100</span></span>
          </div>
          <div class="hp-bar-outer">
              <div id="hp-bar-inner"></div>
          </div>
        </div>

        <div class="inventory" id="inventoryBar">
          <div class="inv-panel" id="invPanel"></div>
        </div>

        <div class="fade" id="fade" style="position:absolute;inset:0;background:#000;opacity:0;pointer-events:none;z-index:90;transition:opacity .45s"></div>
      </div>
    </div>
  </div>

  <div class="admin-mode">
    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px">
      <div><h1 style="margin:0;color:var(--accent);font-size:20px;">Admin</h1>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button class="btn" id="btn-admin-logout">Logout</button>
    </div>
    </div>

    <div class="admin-grid">
      <div class="admin-panel-container-left">
        <div class="admin-panel" id="tabs-panel-left" data-tab-container="true">
          <div class="tab-headers">
            <button class="tab-btn active" data-tab="config">Config</button>
            <button class="tab-btn" data-tab="scenes">Scenes</button>
          </div>

          <div class="tab-content-wrapper">
            
            <div class="tab-content active" data-tab-content="config">
              <h2>Game Config</h2>
              <div class="admin-panel-content">
                  <form id="config-form">
                    <div class="form-group"><label>Starting HP</label><input id="config-starting-hp" type="number" value="100"></div>
                    <div class="form-group"><label>Global BGM URL</label><input id="config-bgm-url" placeholder="https://..."></div>
                    <div class="form-group"><label>Inspect SFX URL</label><input id="config-sfx-url" placeholder="https://..."></div>
                    <div class="form-group"><label>Opening Dialogue (Optional)</label><textarea id="config-opening-dialogue" rows="3"></textarea></div>
                    <div class="form-button-group">
                      <button class="btn primary" type="submit">Save</button>
                    </div>
                  </form>
              </div>
            </div>

            <div class="tab-content" data-tab-content="scenes">
              <div class="admin-panel-header">
                <h2>Scenes</h2>
                <div class="header-buttons">
                  <button class="btn ghost btn-sm" id="btn-toggle-scene-select" type="button">Select</button>
                </div>
              </div>
              <div class="admin-panel-content">
                  <form id="scene-form">
                    <div class="form-group"><label>Scene ID</label><input id="scene-id" required></div>
                    <div class="form-group"><label>Scene Title</label><input id="scene-title" required></div>
                    <div class="form-group"><label>Background URL</label><input id="scene-bg-url" required></div>
                    <div class="form-group"><label>Scene BGM URL (Optional)</label><input id="scene-bgm-url"></div>
                    <div class="form-button-group">
                      <button class="btn ghost" id="btn-clear-scene-form" type="button">Clear</button>
                      <button class="btn primary" type="submit">Save</button>
                    </div>
                  </form>
                  <div class="admin-panel-list" id="scene-list"></div>
              </div>
            </div>

          </div>
        </div>
      </div>
      <div class="admin-main">
        <h2 style="margin-top:0;">Hotspot Editor</h2>
        <p style="margin-top:0;color:#aaa">ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ</p>
        <div id="hotspot-editor-preview"></div>
        <div style="margin-top:12px; text-align:center;">
             <button class="btn primary" id="btn-add-hotspot">Add Hotspot</button> </div>

        <div id="hotspot-form-container" style="display:none;margin-top:12px" class="admin-panel">
          <h3 id="hotspot-form-title">Edit Hotspot</h3>
          <form id="hotspot-form">
            <div class="form-group">
              <label>Hotspot ID</label>
              <input id="hotspot-id" required>
            </div>
            <div class="form-group"><label>Label</label><input id="hotspot-label" required></div>
            <input type="hidden" id="hotspot-x">
            <input type="hidden" id="hotspot-y">
            <input type="hidden" id="hotspot-w">
            <input type="hidden" id="hotspot-h">

            <div class="form-group"><label>Inspect Text</label><textarea id="hotspot-text"></textarea></div>
            <div class="form-group"><label>Inspect Image URL</label><input id="hotspot-inspect-img"></div>
            <div class="form-group"><label>HP Cost (on Inspect)</label><input id="hotspot-hp-cost" type="number" value="0"></div>
            <div class="form-group"><label>HP Cost Text (Optional)</label><textarea id="hotspot-hp-cost-text"></textarea></div>
            <div class="form-group"><label>Gives Item (on Inspect)</label><select id="hotspot-gives"><option value="">-- 없음 --</option></select></div>
            <div class="form-group"><label>Requires Item</label><select id="hotspot-requires"><option value="">-- 없음 --</option></select></div>
            <div class="form-group" style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" id="hotspot-consumes" style="width: auto;">
              <label for="hotspot-consumes" style="margin: 0; width: auto;">Consume Required Item on Use</label>
            </div>
            <div class="form-group"><label>Success Text (Item/Unlock)</label><textarea id="hotspot-success-text"></textarea></div>
            <div class="form-group"><label>Gives Item (on Use Success)</label><select id="hotspot-gives-on-use"><option value="">-- 없음 --</option></select></div>
            <div class="form-group"><label>Already Inspected Text (Optional)</label><textarea id="hotspot-already-inspected-text"></textarea></div>
            <div class="form-group"><label>On Success Scene</label><select id="hotspot-onsuccess-scene"><option value="">-- 없음 --</option></select></div>
            <div class="form-button-group">
              <button class="btn primary" type="submit">Save</button>
            </div>
          </form>
        </div>
      </div>

      <div class="admin-panel-container-right">
        <div class="admin-panel" id="tabs-panel-right" data-tab-container="true">
          <div class="tab-headers">
            <button class="tab-btn active" data-tab="hotspots">Hotspots</button>
            <button class="tab-btn" data-tab="items">Items</button>
          </div>

          <div class="tab-content-wrapper">

            <div class="tab-content active" data-tab-content="hotspots">
              <div class="panel-button-bar">
                <button class="btn ghost btn-sm" id="btn-toggle-hotspot-select">Select</button>
              </div>
              <div id="hotspot-list-container" class="admin-panel-list" style="margin-top: 0px;">
                <p style="color:#aaa;text-align:center;margin-top:20px;">씬을 선택하면 핫스팟 목록이 표시됩니다.</p>
              </div>
            </div>

            <div class="tab-content" data-tab-content="items">
              <div class="admin-panel-header">
                <h2>Items</h2>
                <div class="header-buttons">
                  <button class="btn ghost btn-sm" id="btn-toggle-item-select" type="button">Select</button>
                </div>
              </div>
              <div class="admin-panel-content">
                  <form id="item-form">
                    <div class="form-group"><label>Item ID</label><input id="item-id" required></div>
                    <div class="form-group"><label>Item Name</label><input id="item-name" required></div>
                    <div class="form-group"><label>Image URL</label><input id="item-img-url"></div>
                    <div class="form-group"><label>Item Description</label><textarea id="item-description"></textarea></div>
                    
                    <div class="form-group"><label>Item Type</label>
                      <select id="item-type">
                          <option value="normal">Normal</option>
                          <option value="healing">Healing</option>
                      </select>
                    </div>
                    <div class="form-group sub-group" id="item-healing-group">
                        <div class="form-group"><label>Heal Amount</label><input id="item-heal-amount" type="number" value="10"></div>
                        <div class="form-group"><label>Uses (per item)</label><input id="item-uses" type="number" value="1" min="1"></div>
                    </div>
                    
                    <div class="form-button-group">
                      <button class="btn primary" type="submit">Save</button>
                    </div>
                  </form>
                  <div class="admin-panel-list" id="item-list"></div>
              </div>
            </div>

          </div>
        </div>
      </div>
      </div>
  </div>

  <div class="login-modal-overlay" id="admin-login-modal">
    <div class="login-modal-content">
      <form id="admin-login-form">
        <h2 style="margin-top:0;color:var(--accent)">관리자 로그인</h2>
        <div class="form-group"><label>비밀번호</label><input id="admin-password" type="password" required></div>
        <div style="display:flex;gap:8px">
          <button class="btn primary" type="submit">로그인</button>
          <button class="btn ghost" type="button" id="btn-cancel-login">취소</button>
        </div>
        <div id="login-error-msg" style="height:22px;color:var(--danger);margin-top:6px"></div>
      </form>
    </div>
  </div>

  <div class="login-modal-overlay" id="player-login-modal"><div class="login-modal-content"><form id="player-login-form"><h2 style="margin-top:0;color:var(--accent)">플레이어 ID</h2><div class="form-group"><label>Player ID</label><input id="player-id-input" required></div><div style="display:flex;gap:8px"><button class="btn primary" type="submit">Load / Save</button><button class="btn ghost" type="button" id="btn-cancel-player">취소</button></div><div id="player-login-error-msg" style="height:18px;color:var(--danger)"></div></form></div></div>

  <div class="login-modal-overlay" id="notify-modal" style="z-index: 210;">
    <div class="login-modal-content" style="width: 360px;">
      <h3 id="notify-title" style="margin-top:0; color:var(--accent)">알림</h3>
      <p id="notify-text" style="margin-bottom: 20px; white-space: pre-wrap;">내용</p>
      <div style="display:flex; justify-content:flex-end; gap:8px;">
        <button class="btn ghost" id="notify-cancel">취소</button>
        <button class="btn primary" id="notify-ok">확인</button>
      </div>
    </div>
  </div>
  
  <div class="login-modal-overlay" id="item-info-modal" style="z-index: 220;">
    <div class="login-modal-content" style="width: 360px;">
      <h3 id="item-info-title" style="margin-top:0; color:var(--accent)">아이템 정보</h3>
      <p id="item-info-text" style="margin-bottom: 20px; white-space: pre-wrap; word-break: break-all;">아이템 설명</p>
      <div id="item-info-healing-details">
          HP 회복: <span id="item-info-heal-amount"></span><br>
          남은 총 사용 횟수: <span id="item-info-uses"></span>
      </div>
      <div style="display:flex; justify-content: space-between; gap:8px;">
        <button class="btn ghost danger" id="btn-item-info-drop" style="display:none;">버리기</button>
        <div style="display:flex; justify-content:flex-end; gap:8px;">
            <button class="btn" id="btn-item-info-use" style="display:none;">사용</button>
            <button class="btn primary" id="btn-item-info-close">닫기</button>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
  import Sortable from 'https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/modular/sortable.esm.js';

  const firebaseConfig = {
    apiKey: "AIzaSyAnul0m3AB6Rfm5o2NSPab5qkIg23YmNt0",
    authDomain: "evervalen-d01e2.firebaseapp.com",
    projectId: "evervalen-d01e2",
    storageBucket: "evervalen-d01e2.firebasestorage.app",
    messagingSenderId: "854277067793",
    appId: "1:854277067793:web:87a35e884ee96f16a10db0"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const initialSceneData = { "room": { id: "room", title: "어두운 방", backgroundUrl: "data:image/svg+xml;utf8," + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='960' height='600'><rect width='100%' height='100%' fill='#0b0b10'/></svg>`), bgmUrl: null } };
  const initialItemData = { "key": { id: "key", name: "낡은 열쇠", description: "녹이 슬어 보이는 낡은 열쇠. 어떤 문을 여는 데 사용할 수 있을 것 같다.", imgUrl: "data:image/svg+xml;utf8," + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><g fill='#bfb56b'/></svg>`), itemType: "normal", uses: 1 } };
  const initialHotspotData = { "door": { id: "door", sceneId: "room", label: "굳게 잠긴 문", area: {x:0.35,y:0.25,w:0.22,h:0.5}, inspect:{text:"나갈 수 있는 문이다.",inspectImgUrl:null,requiresItem:"key",successText:"문이 열렸다.",onSuccessScene:"hall", hpCost: 0, hpCostText: null} } };
  
  const gameData = {
    scenes: initialSceneData,
    sceneOrder: Object.keys(initialSceneData),
    items: initialItemData,
    hotspots: initialHotspotData,
    config: { startingHp: 100, bgmUrl: '', inspectSfxUrl: '', openingDialogue: '' }
  };

  let currentPlayerId = 'local_player';
  const getInitialPlayerState = (maxHp) => ({
    currentScene: 'room',
    inventory: {},
    unlockedHotspots: {},
    inspectedHotspots: {},
    itemState: {},
    selectedItem: null,
    hp: maxHp
  });

  let playerState = getInitialPlayerState(gameData.config.startingHp);

  
  function saveLocalPlayerState(){ 
    const key = `pnc_horror_playerstate_${currentPlayerId}`; 
    if (currentPlayerId === 'local_player') {
        localStorage.removeItem(key);
        return;
    }
    localStorage.setItem(key, JSON.stringify(playerState)); 
  }
  function loadLocalPlayerState(){ 
    const key = `pnc_horror_playerstate_${currentPlayerId}`; 
    const maxHp = gameData.config?.startingHp || 100;
    
    if (currentPlayerId === 'local_player') {
        playerState = getInitialPlayerState(maxHp);
        return;
    }
    
    const s = localStorage.getItem(key); 
    if(s){ 
        playerState = JSON.parse(s); 
    } else { 
        playerState = getInitialPlayerState(maxHp); 
        saveLocalPlayerState(); 
    } 
    
    if (playerState.hp === undefined) playerState.hp = maxHp;
    if (!playerState.inspectedHotspots) playerState.inspectedHotspots = {};
    if (!playerState.itemState) playerState.itemState = {};
  }

  
  async function saveGameToFirestore(){ 
    try{ 
        const payload = JSON.parse(JSON.stringify(gameData)); 
        payload.sceneOrder = Array.isArray(gameData.sceneOrder) ? gameData.sceneOrder : Object.keys(gameData.scenes);
        payload.config = gameData.config || { startingHp: 100, bgmUrl: '', inspectSfxUrl: '', openingDialogue: '' };
        await setDoc(doc(db,'game','master'), payload); 
        console.log('Saved game -> Firestore'); 
        showNotify('게임 데이터가 Firestore에 저장되었습니다.'); 
    }catch(err){console.error('Save game failed',err); showNotify('저장 실패', '오류');} 
  }
  async function loadGameFromFirestore(){ 
    try{ 
        const snap = await getDoc(doc(db,'game','master')); 
        if(snap.exists()){ 
            const remote = snap.data();
            Object.assign(gameData.scenes, remote.scenes || {});
            Object.assign(gameData.items, remote.items || {});
            Object.assign(gameData.hotspots, remote.hotspots || {});
            Object.assign(gameData.config, remote.config || {});
            
            
            gameData.sceneOrder = remote.sceneOrder && Array.isArray(remote.sceneOrder) && remote.sceneOrder.length > 0
                ? remote.sceneOrder.filter(id => gameData.scenes[id])
                : Object.keys(gameData.scenes);

            console.log('Loaded game from Firestore');
        } else { console.log('No remote game found'); }
    }catch(err){console.error('Load game failed',err);} 
  }

  async function savePlayerToFirestore(){ 
    if (currentPlayerId === 'local_player') return;
    try{ await setDoc(doc(db,'players',currentPlayerId), JSON.parse(JSON.stringify(playerState))); console.log('Saved player to Firestore'); }
    catch(err){console.error('save player failed',err);} 
  }
  async function loadPlayerFromFirestore(){ 
    if (currentPlayerId === 'local_player') return;
    try{ 
        const snap = await getDoc(doc(db,'players',currentPlayerId)); 
        if(snap.exists()){ 
            playerState = snap.data(); 
            if (playerState.hp === undefined) {
                playerState.hp = gameData.config?.startingHp || 100;
            }
            if (!playerState.inspectedHotspots) playerState.inspectedHotspots = {};
            if (!playerState.itemState) playerState.itemState = {};
            
            saveLocalPlayerState(); 
            console.log('Loaded player from Firestore'); 
        } 
    }
    catch(err){console.error('load player failed',err);} 
  }

  
  const sceneBg = document.getElementById('sceneBg');
  const hotspotLayer = document.getElementById('hotspotLayer');
  const inspectPopup = document.getElementById('inspectPopup');
  const popupTitle = document.getElementById('popupTitle');
  const popupText = document.getElementById('popupText');
  const btnInspect = document.getElementById('btnInspect');
  const btnUseItem = document.getElementById('btnUseItem');
  const invPanel = document.getElementById('invPanel');
  const hudScene = document.getElementById('hudScene');
  const hudUserId = document.getElementById('hudUserId');
  const hotspotEditorPreview = document.getElementById('hotspot-editor-preview');

  
  const hpValueEl = document.getElementById('hp-value');
  const hpMaxEl = document.getElementById('hp-max');
  const hpBarInnerEl = document.getElementById('hp-bar-inner');
  
  
  const bgmAudio = document.getElementById('bgm-audio');
  const bgmPlayPause = document.getElementById('bgm-play-pause');
  const bgmVolume = document.getElementById('bgm-volume');
  
  
  let sfxAudio = new Audio();
  let currentBgm = '';

  
  const sceneForm = document.getElementById('scene-form');
  const sceneIdInput = document.getElementById('scene-id');
  const sceneTitleInput = document.getElementById('scene-title');
  const sceneBgUrlInput = document.getElementById('scene-bg-url');
  const sceneBgmUrlInput = document.getElementById('scene-bgm-url');
  const sceneList = document.getElementById('scene-list');
  const btnClearSceneForm = document.getElementById('btn-clear-scene-form');
  
  
  const configForm = document.getElementById('config-form');
  const configStartingHpInput = document.getElementById('config-starting-hp');
  const configBgmUrlInput = document.getElementById('config-bgm-url');
  const configSfxUrlInput = document.getElementById('config-sfx-url');
  const configOpeningDialogueInput = document.getElementById('config-opening-dialogue');

  const itemForm = document.getElementById('item-form');
  const itemIdInput = document.getElementById('item-id');
  const itemNameInput = document.getElementById('item-name');
  const itemImgUrlInput = document.getElementById('item-img-url');
  const itemDescriptionInput = document.getElementById('item-description');
  const itemTypeInput = document.getElementById('item-type');
  const itemHealingGroup = document.getElementById('item-healing-group');
  const itemHealAmountInput = document.getElementById('item-heal-amount');
  const itemUsesInput = document.getElementById('item-uses');
  const itemList = document.getElementById('item-list');

  const hotspotFormContainer = document.getElementById('hotspot-form-container');
  const hotspotFormTitle = document.getElementById('hotspot-form-title');
  const hotspotForm = document.getElementById('hotspot-form');
  const hotspotIdInput = document.getElementById('hotspot-id');
  const hotspotLabel = document.getElementById('hotspot-label');
  const hotspotText = document.getElementById('hotspot-text');
  const hotspotInspectImg = document.getElementById('hotspot-inspect-img');
  const hotspotHpCost = document.getElementById('hotspot-hp-cost');
  const hotspotHpCostText = document.getElementById('hotspot-hp-cost-text');
  const hotspotGives = document.getElementById('hotspot-gives');
  const hotspotRequires = document.getElementById('hotspot-requires');
  const hotspotConsumes = document.getElementById('hotspot-consumes');
  const hotspotGivesOnUse = document.getElementById('hotspot-gives-on-use');
  const hotspotSuccessText = document.getElementById('hotspot-success-text');
  const hotspotAlreadyInspectedText = document.getElementById('hotspot-already-inspected-text');
  const hotspotOnSuccessScene = document.getElementById('hotspot-onsuccess-scene');
  const hotspotX = document.getElementById('hotspot-x');
  const hotspotY = document.getElementById('hotspot-y');
  const hotspotW = document.getElementById('hotspot-w');
  const hotspotH = document.getElementById('hotspot-h');
  const btnDeleteHotspot = document.getElementById('btn-delete-hotspot');
  
  const btnAdminLogout = document.getElementById('btn-admin-logout');
  const btnChangePlayer = document.getElementById('btn-change-player');
  const btnAdminLogin = document.getElementById('btn-admin-login');
  const btnAddHotspot = document.getElementById('btn-add-hotspot');
  
  const btnToggleSceneSelect = document.getElementById('btn-toggle-scene-select');
  const btnToggleHotspotSelect = document.getElementById('btn-toggle-hotspot-select');
  const btnToggleItemSelect = document.getElementById('btn-toggle-item-select');
  const hotspotListContainer = document.getElementById('hotspot-list-container');

  
  const adminLoginModal = document.getElementById('admin-login-modal');
  const adminLoginForm = document.getElementById('admin-login-form');
  const adminPasswordInput = document.getElementById('admin-password');
  const loginErrorMsg = document.getElementById('login-error-msg');

  const playerLoginModal = document.getElementById('player-login-modal');
  const playerLoginForm = document.getElementById('player-login-form');
  const playerIdInput = document.getElementById('player-id-input');

  const notifyModal = document.getElementById('notify-modal');
  const notifyTitle = document.getElementById('notify-title');
  const notifyText = document.getElementById('notify-text');
  const notifyOk = document.getElementById('notify-ok');
  const notifyCancel = document.getElementById('notify-cancel');
  
  
  const itemInfoModal = document.getElementById('item-info-modal');
  const itemInfoTitle = document.getElementById('item-info-title');
  const itemInfoText = document.getElementById('item-info-text');
  const itemInfoHealingDetails = document.getElementById('item-info-healing-details');
  const itemInfoHealAmount = document.getElementById('item-info-heal-amount');
  const itemInfoUses = document.getElementById('item-info-uses');
  const btnItemInfoUse = document.getElementById('btn-item-info-use');
  const btnItemInfoDrop = document.getElementById('btn-item-info-drop');
  const btnItemInfoClose = document.getElementById('btn-item-info-close');

  const popupHotspotLabelEl = document.getElementById('popupHotspotLabel');
  const popupContinueEl = document.getElementById('popupContinue');
  const choicePopup = document.getElementById('choicePopup');
  const btnMoveFromSuccess = document.getElementById('btnMoveFromSuccess');

  let adminSelectedSceneId = null;
  let adminSelectedHotspotId = null;
  let currentHotspot = null;
  let notifyResolve = null;
  let isIntroPlaying = false;
  
  let tempHotspotData = null;
  
  let typewritingTimer = null;
  let currentTextPages = [];
  let currentPageIndex = 0;

  
  function playSound(url) {
    if (url) {
        sfxAudio.src = url;
        sfxAudio.play().catch(e => console.warn("SFX play failed", e));
    }
  }

  function playBgm(url) {
    if (!url) {
        if (currentBgm) {
            bgmAudio.pause();
            currentBgm = '';
            bgmAudio.src = '';
        }
        return;
    }
    if (url === currentBgm && !bgmAudio.paused) {
        return; 
    }
    
    currentBgm = url;
    bgmAudio.src = url;
    bgmAudio.play().catch(e => console.warn('BGM play failed', e));
  }

  
  function updateHpUI() {
    const maxHp = gameData.config?.startingHp || 100;
    const currentHp = playerState.hp;
    
    hpValueEl.textContent = currentHp;
    hpMaxEl.textContent = maxHp;
    
    const percent = Math.max(0, Math.min(100, (currentHp / maxHp) * 100));
    hpBarInnerEl.style.width = percent + '%';
  }
  
  async function handleGameOver() {
    await showNotify('HP가 0이 되었습니다. 처음부터 다시 시작합니다.', '게임 오버');
    const startScene = gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0] || 'room';
    
    playerState = getInitialPlayerState(gameData.config?.startingHp || 100);
    playerState.currentScene = startScene;
    
    loadScene(startScene, true);
    renderInventory();
    updateHpUI();
    saveLocalPlayerState();
    savePlayerToFirestore();
  }

  
  function showNotify(text, title = '알림', type = 'alert') {
    notifyTitle.textContent = title;
    notifyText.textContent = text;
    
    if (type === 'alert') {
      notifyCancel.style.display = 'none';
      notifyOk.textContent = '확인';
    } else {
      notifyCancel.style.display = 'inline-block';
      notifyOk.textContent = '확인';
      notifyCancel.textContent = '취소';
    }
    
    notifyModal.style.display = 'flex';

    return new Promise((resolve) => {
      notifyResolve = resolve;
    });
  }

  function closeNotify(result) {
    notifyModal.style.display = 'none';
    if (notifyResolve) {
      notifyResolve(result);
      notifyResolve = null;
    }
  }

  function showOpeningDialogue(dialogueText) {
    if (!dialogueText || dialogueText.trim() === '') return;

    const pages = [];
    const matches = dialogueText.matchAll(/\[([^\]]+)\]/g);
    
    let hasMatches = false;
    for (const match of matches) {
        pages.push(match[1]);
        hasMatches = true;
    }

    if (!hasMatches) {
        pages.push(dialogueText);
    } else if (pages.length === 0) {
        return; 
    }

    isIntroPlaying = true;
    currentTextPages = pages;
    currentPageIndex = 0;

    popupHotspotLabelEl.textContent = currentPlayerId;
    const oldImg = document.getElementById('popupImg'); 
    if(oldImg) oldImg.remove();
    
    choicePopup.classList.remove('show');
    inspectPopup.classList.add('show');

    typeWriter(currentTextPages[currentPageIndex], () => {
        checkContinue();
        if (currentPageIndex === currentTextPages.length - 1) {
            isIntroPlaying = false;
        }
    });
  }

  notifyOk.addEventListener('click', () => closeNotify(true));
  notifyCancel.addEventListener('click', () => closeNotify(false));
  btnItemInfoClose.addEventListener('click', () => {
    itemInfoModal.style.display = 'none';
  });
  btnItemInfoDrop.addEventListener('click', () => onItemDropClick());

  
  function stopTypewriter() {
      if (typewritingTimer) {
          clearInterval(typewritingTimer);
          typewritingTimer = null;
      }
  }

  function typeWriter(text, onComplete) {
      stopTypewriter();
      let i = 0;
      popupText.textContent = '';
      
      function type() {
          if (i < text.length) {
              popupText.textContent += text.charAt(i);
              i++;
          } else {
              stopTypewriter();
              if (onComplete) onComplete();
          }
      }
      
      typewritingTimer = setInterval(type, 30);
  }

  function skipTyping() {
      if (typewritingTimer) {
          stopTypewriter();
          popupText.textContent = currentTextPages[currentPageIndex];
          checkContinue();
          if (isIntroPlaying && currentPageIndex === currentTextPages.length - 1) { 
              isIntroPlaying = false;
          }
      } else if (popupContinueEl.style.display === 'block') {
          showNextPage();
      }
  }
  
  function checkContinue() {
      if (currentPageIndex < currentTextPages.length - 1) {
          popupContinueEl.style.display = 'block';
      } else {
          popupContinueEl.style.display = 'none';
      }
  }

  function showNextPage() {
      if (typewritingTimer) return;
      if (currentPageIndex < currentTextPages.length - 1) {
          currentPageIndex++;
          typeWriter(currentTextPages[currentPageIndex], () => { 
              checkContinue();
              if (isIntroPlaying && currentPageIndex === currentTextPages.length - 1) { 
                  isIntroPlaying = false;
              }
          });
      }
  }

  function paginateText(fullText) {
      currentTextPages = fullText.split('\n\n');
      currentPageIndex = 0;
      typeWriter(currentTextPages[currentPageIndex], checkContinue);
  }

  function init(){
    onAuthStateChanged(auth, async (user)=>{ 
      if(user){ 
        document.body.dataset.mode='admin'; 
        playBgm(null);
        initAdminMode(); 
      } else { 
        currentPlayerId = 'local_player';
        document.body.dataset.mode='player'; 
        await initPlayerMode(); 
      } 
    });
    
    btnChangePlayer.addEventListener('click', onPlayerModeClick);
    btnAdminLogin.addEventListener('click', onAdminModeClick);

    btnInspect.addEventListener('click', () => onInspectClickLogic()); 
    btnUseItem.addEventListener('click', onUseItemClick); 
    
    popupText.addEventListener('click', skipTyping);
    popupContinueEl.addEventListener('click', showNextPage);
    
    
    bgmPlayPause.addEventListener('click', () => {
        if (bgmAudio.paused) { 
            bgmAudio.play().catch(e => console.warn('BGM play failed. User interaction may be required.', e)); 
        } else { 
            bgmAudio.pause(); 
        }
    });
    bgmVolume.addEventListener('input', () => {
        bgmAudio.volume = bgmVolume.value;
        localStorage.setItem('pnc_horror_bgm_volume', bgmVolume.value);
    });
    bgmAudio.addEventListener('play', () => { bgmPlayPause.textContent = 'Pause'; });
    bgmAudio.addEventListener('pause', () => { bgmPlayPause.textContent = 'Play'; });
    
    loadGameFromFirestore().then(()=>{ 
        
        const initialSceneId = gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0] || 'room';
        
        if (document.body.dataset.mode === 'player') {
            
            const openingDialogue = gameData.config?.openingDialogue || '';
            if (openingDialogue) {
                if (currentPlayerId === 'local_player') {
                    showOpeningDialogue(openingDialogue);
                } else {
                    if (!sessionStorage.getItem('pnc_horror_intro_shown')) {
                        showOpeningDialogue(openingDialogue);
                        sessionStorage.setItem('pnc_horror_intro_shown', 'true');
                    }
                }
            }
            
            const sceneToLoad = playerState.currentScene || initialSceneId;
            loadScene(sceneToLoad, false);
        } else if (document.body.dataset.mode === 'admin') {
            renderAdminLists();
            
            configStartingHpInput.value = gameData.config?.startingHp || 100;
            configBgmUrlInput.value = gameData.config?.bgmUrl || '';
            configSfxUrlInput.value = gameData.config?.inspectSfxUrl || '';
            configOpeningDialogueInput.value = gameData.config?.openingDialogue || '';
        }
    });
  }
  
  async function onPlayerModeClick() {
    if (auth.currentUser) {
      showNotify('관리자 계정에서 로그아웃하면 플레이어 모드로 전환됩니다. 로그아웃하시겠습니까?', '모드 전환 확인', 'confirm').then(async (res) => {
        if (res) {
          await signOut(auth);
        }
      });
    } else if (currentPlayerId !== 'local_player') {
        const confirmed = await showNotify(
            `'${currentPlayerId}'에서 로그아웃하고 로컬 플레이어로 전환하시겠습니까? (현재 진행 상황은 저장됩니다.)`, 
            '플레이어 전환', 
            'confirm'
        );
        if (confirmed) {
            await savePlayerToFirestore(); 
            currentPlayerId = 'local_player';
            hudUserId.textContent = currentPlayerId;
            loadLocalPlayerState(); 
            
            if (playerState.hp === undefined) {
               playerState.hp = gameData.config?.startingHp || 100;
            }
            renderInventory();
            updateHpUI();
            const sceneToLoad = playerState.currentScene || gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0] || 'room';
            loadScene(sceneToLoad, false);
        }
    } else {
      playerIdInput.value= '';
      playerLoginModal.style.display='flex';
      playerIdInput.focus();
    }
  }

  function onAdminModeClick() {
    if (auth.currentUser) {
      document.body.dataset.mode = 'admin';
      initAdminMode();
    } else {
      adminLoginModal.style.display='flex';
      adminPasswordInput.value=''; 
      loginErrorMsg.textContent=''; 
      adminPasswordInput.focus();
    }
  }

  
  function initAdminTabs() {
      document.querySelectorAll('[data-tab-container]').forEach(tabContainer => {
          const tabButtons = tabContainer.querySelectorAll('.tab-btn');
          const tabContents = tabContainer.querySelectorAll('.tab-content');

          if (tabButtons.length === 0) return;

          tabButtons.forEach(button => {
              button.addEventListener('click', (e) => {
                  e.preventDefault();
                  
                  tabButtons.forEach(btn => btn.classList.remove('active'));
                  tabContents.forEach(content => content.classList.remove('active'));

                  button.classList.add('active');
                  const tabId = button.dataset.tab;
                  const activeContent = tabContainer.querySelector(`.tab-content[data-tab-content="${tabId}"]`);
                  if (activeContent) {
                      activeContent.classList.add('active');
                  }
              });
          });
          
          if (!tabContainer.querySelector('.tab-btn.active')) {
              tabButtons[0].classList.add('active');
              tabContents[0].classList.add('active');
          }
      });
  }

  function initAdminMode(){
    renderAdminLists();
    drawHotspotsInEditor();
    initAdminTabs(); 
    
    
    configStartingHpInput.value = gameData.config?.startingHp || 100;
    configBgmUrlInput.value = gameData.config?.bgmUrl || '';
    configSfxUrlInput.value = gameData.config?.inspectSfxUrl || '';
    configOpeningDialogueInput.value = gameData.config?.openingDialogue || '';

    btnAdminLogout.addEventListener('click', async ()=>{ await signOut(auth); showNotify('로그아웃 되었습니다.'); });
    
    
    btnAddHotspot.addEventListener('click', onAddHotspotClick);
    
    
    itemTypeInput.addEventListener('change', () => {
        itemHealingGroup.classList.toggle('show', itemTypeInput.value === 'healing');
    });
    
    btnToggleSceneSelect.addEventListener('click', toggleSceneSelectMode);
    btnToggleHotspotSelect.addEventListener('click', toggleHotspotSelectMode);
    btnToggleItemSelect.addEventListener('click', toggleItemSelectMode);
  }

  
  function setupSceneDragAndDrop() {
    new Sortable(sceneList, {
        animation: 150,
        handle: '.drag-handle',
        onEnd: function (evt) {
            const items = sceneList.querySelectorAll('.admin-panel-list-item');
            const newOrder = Array.from(items).map(item => item.dataset.sceneId);
            gameData.sceneOrder = newOrder;
            saveGameToFirestore();
        }
    });
  }

  function renderAdminLists(){
    
    const sceneSelectMode = sceneList.classList.contains('select-mode');
    sceneList.innerHTML=''; 
    if (sceneSelectMode) sceneList.classList.add('select-mode');
    
    const sceneOptions = ['<option value="">-- 없음 --</option>'];
    
    
    gameData.sceneOrder.forEach(sceneId=>{
        const scene = gameData.scenes[sceneId];
        if(!scene) return;
        
        const item = document.createElement('div'); 
        item.className='admin-panel-list-item'; 
        item.dataset.sceneId = scene.id; 

        item.innerHTML = `
            <input type="checkbox" class="scene-select-cb item-select-cb" data-scene-id="${scene.id}">
            <span class="drag-handle">&#x2261;</span>
            <span class="item-label">${scene.title}<br><code class="item-id-code">${scene.id}</code></span>
            <div class="item-buttons">
                <button class='btn btn-sm' data-id-edit='${scene.id}'>Edit</button>
                <button class='btn ghost btn-sm' data-id-copy='${scene.id}'>Copy</button>
                <button class='btn ghost danger btn-sm' data-id-delete='${scene.id}'>Delete</button>
            </div>
        `;
        
        
        item.querySelector('.item-select-cb').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        item.querySelector('.item-label').addEventListener('click', (e) => {
            e.stopPropagation();
            loadSceneInEditor(scene.id);
        });
        
        
        item.querySelector('button[data-id-edit]').addEventListener('click',()=>{ 
            loadSceneInEditor(scene.id);
            sceneIdInput.value=scene.id; 
            sceneIdInput.disabled=true; 
            sceneTitleInput.value=scene.title; 
            sceneBgUrlInput.value=scene.backgroundUrl; 
            sceneBgmUrlInput.value = scene.bgmUrl || '';
        });
        
        
        item.querySelector('button[data-id-copy]').addEventListener('click', async (e)=>{
            e.stopPropagation();
            const sceneIdToCopy = e.target.dataset.idCopy;
            const sceneToCopy = gameData.scenes[sceneIdToCopy];
            if (!sceneToCopy) return;

            const newSceneId = `scene_${Date.now()}`;
            const newScene = JSON.parse(JSON.stringify(sceneToCopy));
            newScene.id = newSceneId;
            newScene.title = `${sceneToCopy.title} (Copy)`;
            
            gameData.scenes[newSceneId] = newScene;

            const originalIndex = gameData.sceneOrder.indexOf(sceneIdToCopy);
            gameData.sceneOrder.splice(originalIndex + 1, 0, newSceneId);

            
            Object.values(gameData.hotspots).filter(hs => hs.sceneId === sceneIdToCopy).forEach((hsToCopy, i) => {
                const newHotspotId = `hs_${newSceneId}_${i}`;
                const newHotspot = JSON.parse(JSON.stringify(hsToCopy));
                newHotspot.id = newHotspotId;
                newHotspot.sceneId = newSceneId;
                gameData.hotspots[newHotspotId] = newHotspot;
            });

            renderAdminLists();
            await saveGameToFirestore();
        });
        
        
        item.querySelector('button[data-id-delete]').addEventListener('click', async ()=>{
            if(gameData.sceneOrder.length <= 1) {
                showNotify('씬은 최소 한 개 이상 존재해야 합니다.', '삭제 불가');
                return;
            }
            if(await showNotify(`씬 '${scene.title}'를 정말 삭제하시겠습니까? (저장하지 않으면 복구 가능)`, '씬 삭제 확인', 'confirm')){
                delete gameData.scenes[scene.id];
                gameData.sceneOrder = gameData.sceneOrder.filter(id => id !== scene.id);
                Object.keys(gameData.hotspots).forEach(hsId => {
                    if(gameData.hotspots[hsId].sceneId === scene.id) {
                        delete gameData.hotspots[hsId];
                    }
                });
                renderAdminLists();
                await saveGameToFirestore();
            }
        });
        
        sceneList.appendChild(item);
        sceneOptions.push(`<option value='${scene.id}'>${scene.title} (${scene.id})</option>`);
    });

    setupSceneDragAndDrop();

    
    const itemSelectMode = itemList.classList.contains('select-mode');
    itemList.innerHTML = '';
    if (itemSelectMode) itemList.classList.add('select-mode');
    
    const itemOptions=['<option value="">-- 없음 --</option>'];
    Object.values(gameData.items).forEach(it=>{
        const itemEl=document.createElement('div'); 
        itemEl.className='admin-panel-list-item'; 
        itemEl.innerHTML=`
            <input type="checkbox" class="item-select-cb" data-item-id="${it.id}">
            <span class="item-label">${it.name}<br><code class="item-id-code">${it.id}</code></span>
            <div class="item-buttons">
                <button class='btn btn-sm' data-edit='${it.id}'>Edit</button>
                <button class='btn ghost danger btn-sm' data-delete='${it.id}'>Delete</button>
            </div>`;
        
        itemEl.querySelector('.item-select-cb').addEventListener('click', (e) => {
            e.stopPropagation();
        });
            
        itemEl.querySelector('button[data-edit]').addEventListener('click',()=>{ 
            itemIdInput.value=it.id; 
            itemIdInput.disabled=true; 
            itemNameInput.value=it.name; 
            itemImgUrlInput.value=it.imgUrl||''; 
            itemDescriptionInput.value=it.description||'';
            itemTypeInput.value = it.itemType || 'normal';
            itemHealAmountInput.value = it.healAmount || 0;
            itemUsesInput.value = it.uses || 1;
            itemHealingGroup.classList.toggle('show', itemTypeInput.value === 'healing');
        });
        
        itemEl.querySelector('button[data-delete]').addEventListener('click', async ()=>{
            if(await showNotify(`아이템 '${it.name}'를 정말 삭제하시겠습니까?`, '아이템 삭제 확인', 'confirm')){
                delete gameData.items[it.id];
                renderAdminLists();
                await saveGameToFirestore();
            }
        });
        
        itemEl.querySelector('.item-label').addEventListener('click', (e) => {
            e.stopPropagation();
            itemEl.querySelector('button[data-edit]').click();
        });

        itemList.appendChild(itemEl);
        itemOptions.push(`<option value='${it.id}'>${it.name} (${it.id})</option>`);
    });

    
    hotspotGives.innerHTML=itemOptions.join(''); 
    hotspotRequires.innerHTML=itemOptions.join(''); 
    hotspotGivesOnUse.innerHTML = itemOptions.join('');
    hotspotOnSuccessScene.innerHTML=sceneOptions.join('');
    
    if (adminSelectedSceneId) {
        renderHotspotsForEditor(adminSelectedSceneId);
    }
  }

  sceneForm.addEventListener('submit',(e)=>{ 
    e.preventDefault(); 
    const id=sceneIdInput.value.trim(); 
    if(!id) return; 
    
    const isNew = !gameData.scenes[id];
    
    gameData.scenes[id]={
        id,
        title:sceneTitleInput.value||id,
        backgroundUrl:sceneBgUrlInput.value||'',
        bgmUrl: sceneBgmUrlInput.value.trim() || null
    }; 
    
    if(isNew) {
        gameData.sceneOrder.push(id);
    }

    sceneForm.reset(); 
    sceneIdInput.disabled=false; 
    renderAdminLists(); 
    saveGameToFirestore();
  });
  btnClearSceneForm.addEventListener('click',()=>{ sceneForm.reset(); sceneIdInput.disabled=false; adminSelectedSceneId=null; hotspotEditorPreview.style.backgroundImage=''; closeHotspotForm(); renderAdminLists(); });

  itemForm.addEventListener('submit',(e)=>{ 
    e.preventDefault(); 
    const id=itemIdInput.value.trim(); 
    if(!id) return; 
    
    const itemType = itemTypeInput.value || 'normal';
    let healAmount = 0;
    let uses = 1;
    
    if (itemType === 'healing') {
        healAmount = parseInt(itemHealAmountInput.value, 10) || 0;
        uses = parseInt(itemUsesInput.value, 10) || 1;
        if (uses < 1) uses = 1;
    }
    
    gameData.items[id]={
        id,
        name:itemNameInput.value||id,
        imgUrl:itemImgUrlInput.value||'',
        description:itemDescriptionInput.value||'',
        itemType: itemType,
        healAmount: healAmount,
        uses: uses
    }; 
    itemForm.reset(); 
    itemHealingGroup.classList.remove('show');
    itemIdInput.disabled=false; 
    renderAdminLists(); 
    saveGameToFirestore();
  });
  
  configForm.addEventListener('submit', (e) => {
    e.preventDefault();
    gameData.config.startingHp = parseInt(configStartingHpInput.value, 10) || 100;
    gameData.config.bgmUrl = configBgmUrlInput.value.trim() || '';
    gameData.config.inspectSfxUrl = configSfxUrlInput.value.trim() || '';
    gameData.config.openingDialogue = configOpeningDialogueInput.value.trim() || '';
    saveGameToFirestore();
  });

  
  function onAddHotspotClick() {
    if(!adminSelectedSceneId){ showNotify('먼저 씬을 선택하세요.'); return; }
    
    const newId=`hs_${Date.now()}`; 
    adminSelectedHotspotId=newId; 
    hotspotFormContainer.style.display='block'; 
    hotspotFormTitle.textContent='Create Hotspot'; 
    hotspotIdInput.value = newId;
    hotspotIdInput.disabled = false;
    
    
    const defaultX=0.44, defaultY=0.44, defaultW=0.12, defaultH=0.12;
    hotspotLabel.value='New Hotspot'; 
    hotspotX.value=(defaultX*100).toFixed(2); 
    hotspotY.value=(defaultY*100).toFixed(2); 
    hotspotW.value=(defaultW*100).toFixed(2); 
    hotspotH.value=(defaultH*100).toFixed(2);
    
    hotspotText.value = ''; 
    hotspotInspectImg.value = ''; 
    hotspotHpCost.value = 0;
    hotspotHpCostText.value = '';
    hotspotGives.value = ''; 
    hotspotRequires.value = ''; 
    hotspotConsumes.checked = true;
    hotspotGivesOnUse.value = '';
    hotspotSuccessText.value = ''; 
    hotspotAlreadyInspectedText.value = '';
    hotspotOnSuccessScene.value = '';
    
    
    const tempEl = document.createElement('div');
    tempEl.className = 'editor-hotspot selected';
    tempEl.dataset.id = newId;
    tempEl.style.left = hotspotX.value + '%';
    tempEl.style.top = hotspotY.value + '%';
    tempEl.style.width = hotspotW.value + '%';
    tempEl.style.height = hotspotH.value + '%';
    const handle=document.createElement('div'); handle.className='handle br'; tempEl.appendChild(handle);
    selectEditorHotspot(tempEl);
    drawHotspotsInEditor(tempEl);
    hotspotEditorPreview.appendChild(tempEl);

    tempHotspotData = {
        id: newId, 
        sceneId: adminSelectedSceneId, 
        label:'New Hotspot', 
        area:{x:defaultX,y:defaultY,w:defaultW,h:defaultH}, 
        inspect:{ hpCost: 0, hpCostText: null } 
    };

    hotspotLabel.focus();
  }

  function loadSceneInEditor(sceneId){ 
    const s=gameData.scenes[sceneId]; 
    if(!s) return; 
    adminSelectedSceneId=sceneId; 
    
    sceneIdInput.value=s.id; 
    sceneIdInput.disabled=true; 
    sceneTitleInput.value=s.title; 
    sceneBgUrlInput.value=s.backgroundUrl; 
    sceneBgmUrlInput.value = s.bgmUrl || '';
    
    hotspotEditorPreview.style.backgroundImage = `url('${s.backgroundUrl}')`;
    drawHotspotsInEditor(); 
    closeHotspotForm(); 
    renderHotspotsForEditor(sceneId);
  }
  
  function renderHotspotsForEditor(sceneId) {
    const listContainer = document.getElementById('hotspot-list-container');
    
    const hotspotSelectMode = listContainer.classList.contains('select-mode');
    listContainer.innerHTML = '';
    if (hotspotSelectMode) listContainer.classList.add('select-mode');
    
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';
    ul.style.flexGrow = '1';
    ul.style.minHeight = '0';
    ul.style.overflowY = 'auto';

    const hotspots = Object.values(gameData.hotspots).filter(hs => hs.sceneId === sceneId);
    
    if (hotspots.length === 0) {
        listContainer.innerHTML = '<p style="color:#aaa;text-align:center;margin-top:10px;">핫스팟이 없습니다.</p>';
        return;
    }
    
    hotspots.forEach(hs => {
        const li = document.createElement('li');
        li.className = 'admin-panel-list-item';
        
        li.innerHTML = `
            <input type="checkbox" class="hotspot-select-cb item-select-cb" data-hotspot-id="${hs.id}">
            <span class="item-label">${hs.label}<br><code class="item-id-code">${hs.id}</code></span>
            <div class="item-buttons">
                <button class='btn btn-sm' data-id-edit='${hs.id}'>Edit</button>
                <button class='btn ghost danger btn-sm' data-id-delete='${hs.id}'>Delete</button>
            </div>
        `;
        
        li.querySelector('.item-label').addEventListener('click', (e) => {
            e.stopPropagation();
            loadHotspotInEditor(hs.id);
            const el = document.querySelector(`.editor-hotspot[data-id="${hs.id}"]`);
            if (el) {
                selectEditorHotspot(el);
                el.scrollIntoView({ behavior: 'smooth', block: 'center' }); 
            }
        });
        
        li.querySelector('button[data-id-edit]').addEventListener('click', (e) => {
            e.stopPropagation();
            loadHotspotInEditor(hs.id);
            const el = document.querySelector(`.editor-hotspot[data-id="${hs.id}"]`);
            if (el) {
                selectEditorHotspot(el);
                el.scrollIntoView({ behavior: 'smooth', block: 'center' }); 
            }
        });
        
        li.querySelector('button[data-id-delete]').addEventListener('click', async (e) => {
            e.stopPropagation();
            if (await showNotify(`핫스팟 '${hs.label}' (${hs.id})를 정말 삭제하시겠습니까?`, '핫스팟 삭제 확인', 'confirm')) {
                delete gameData.hotspots[hs.id];
                if (adminSelectedHotspotId === hs.id) {
                    closeHotspotForm();
                }
                drawHotspotsInEditor();
                renderHotspotsForEditor(sceneId);
                await saveGameToFirestore();
            }
        });

        li.querySelector('.item-select-cb').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        ul.appendChild(li);
    });
    listContainer.appendChild(ul);
  }

  function closeHotspotForm() {
    hotspotFormContainer.style.display = 'none';
    hotspotForm.reset();
    hotspotIdInput.disabled = false;
    adminSelectedHotspotId = null;
    tempHotspotData = null;
    hotspotEditorPreview.querySelectorAll('.editor-hotspot.selected').forEach(x=>x.classList.remove('selected'));
  }

  function drawHotspotsInEditor(){ 
    hotspotEditorPreview.querySelectorAll('.editor-hotspot').forEach(x=>x.remove()); 
    if(!adminSelectedSceneId) return; 
    
    Object.values(gameData.hotspots).filter(hs=>hs.sceneId===adminSelectedSceneId).forEach(hs=>{ 
            const el=document.createElement('div'); el.className='editor-hotspot'; el.dataset.id=hs.id; 
            el.style.left=`${hs.area.x*100}%`; el.style.top=`${hs.area.y*100}%`; el.style.width=`${hs.area.w*100}%`; el.style.height=`${hs.area.h*100}%`;
            
            const handle=document.createElement('div'); handle.className='handle br'; el.appendChild(handle);

            let isDragging=false, dragStart={x:0,y:0}, startRect={left:0,top:0};
            
            el.addEventListener('pointerdown',(ev)=>{ 
                ev.stopPropagation(); 
                if(ev.target===handle){ 
                    startResize(ev,el); 
                    return; 
                } 
                adminSelectedHotspotId=hs.id; 
                loadHotspotInEditor(hs.id); 
                selectEditorHotspot(el); 
                isDragging=true; 
                el.setPointerCapture(ev.pointerId); 
                dragStart={x:ev.clientX,y:ev.clientY}; 
                startRect={left:el.offsetLeft,top:el.offsetTop}; 
            });

            el.addEventListener('pointermove',(ev)=>{ 
                if(!isDragging) return; 
                const dx=ev.clientX-dragStart.x; 
                const dy=ev.clientY-dragStart.y; 
                const parentRect=hotspotEditorPreview.getBoundingClientRect(); 
                let newLeft = startRect.left + dx; 
                let newTop = startRect.top + dy;
                newLeft = Math.max(0, Math.min(newLeft, parentRect.width - el.offsetWidth)); 
                newTop = Math.max(0, Math.min(newTop, parentRect.height - el.offsetHeight));
                el.style.left = (newLeft / parentRect.width * 100) + '%'; 
                el.style.top = (newTop / parentRect.height * 100) + '%'; 
                updateHotspotFormFromEditor(el);
            });

            el.addEventListener('pointerup',(ev)=>{ 
                if(isDragging){ 
                    isDragging=false; 
                    try{ el.releasePointerCapture(ev.pointerId);}catch(e){}; 
                    storeEditorHotspotToTemp(el);
                } 
            });

            hotspotEditorPreview.appendChild(el);
    }); 
  }

  function selectEditorHotspot(el){ hotspotEditorPreview.querySelectorAll('.editor-hotspot').forEach(x=>x.classList.remove('selected')); el.classList.add('selected'); }

  function startResize(ev,el){ 
    ev.stopPropagation(); 
    let parentRect = hotspotEditorPreview.getBoundingClientRect(); 
    const start = {mx:ev.clientX,my:ev.clientY,left:el.offsetLeft,top:el.offsetTop,w:el.offsetWidth,h:el.offsetHeight}; 
    el.setPointerCapture(ev.pointerId);
    
    function onMove(e){ 
        const dx = e.clientX - start.mx; const dy = e.clientY - start.my; 
        let newW = start.w + dx; let newH = start.h + dy; 
        newW = Math.max(8, Math.min(newW, parentRect.width - start.left)); 
        newH = Math.max(8, Math.min(newH, parentRect.height - start.top)); 
        el.style.width = (newW/parentRect.width*100) + '%'; 
        el.style.height = (newH/parentRect.height*100) + '%'; 
        updateHotspotFormFromEditor(el); 
    }
    
    function onUp(u){ 
        window.removeEventListener('pointermove', onMove); 
        window.removeEventListener('pointerup', onUp); 
        try{ el.releasePointerCapture(u.pointerId);}catch(e){}; 
        storeEditorHotspotToTemp(el);
    }
    window.addEventListener('pointermove', onMove); 
    window.addEventListener('pointerup', onUp);
  }

  function updateHotspotFormFromEditor(el){ 
    
    const parentRect = hotspotEditorPreview.getBoundingClientRect(); 
    const left = el.offsetLeft/parentRect.width*100; 
    const top = el.offsetTop/parentRect.height*100; 
    const w = el.offsetWidth/parentRect.width*100; 
    const h = el.offsetHeight/parentRect.height*100; 
    
    hotspotX.value = left.toFixed(2); 
    hotspotY.value = top.toFixed(2); 
    hotspotW.value = w.toFixed(2); 
    hotspotH.value = h.toFixed(2); 
    
    
    storeEditorHotspotToTemp(el);
  }

  function storeEditorHotspotToTemp(el){
    const id = el.dataset.id; 
    if(!id || id !== adminSelectedHotspotId) return; 
    
    const parentRect = hotspotEditorPreview.getBoundingClientRect(); 
    
    const area = {
        x: el.offsetLeft / parentRect.width, 
        y: el.offsetTop / parentRect.height, 
        w: el.offsetWidth / parentRect.width, 
        h: el.offsetHeight / parentRect.height
    };

    if (!tempHotspotData || tempHotspotData.id !== id) {
        
        tempHotspotData = JSON.parse(JSON.stringify(gameData.hotspots[id] || { id, sceneId: adminSelectedSceneId, label:'New Hotspot', area:area, inspect:{} }));
    }
    
    tempHotspotData.area = area;
  }

  function loadHotspotInEditor(hotspotId){ 
    const hs = gameData.hotspots[hotspotId]; 
    if(!hs) return; 
    
    adminSelectedHotspotId=hotspotId; 
    hotspotFormContainer.style.display='block'; 
    hotspotFormTitle.textContent=`Edit Hotspot (${hotspotId})`; 
    hotspotIdInput.value = hs.id; 
    hotspotIdInput.disabled = true;
    hotspotLabel.value = hs.label||''; 
    
    tempHotspotData = JSON.parse(JSON.stringify(hs));
    
    
    hotspotX.value = (hs.area.x*100).toFixed(2); 
    hotspotY.value = (hs.area.y*100).toFixed(2); 
    hotspotW.value = (hs.area.w*100).toFixed(2); 
    hotspotH.value = (hs.area.h*100).toFixed(2); 
    
    
    hotspotText.value = hs.inspect?.text||''; 
    hotspotInspectImg.value=hs.inspect?.inspectImgUrl||''; 
    hotspotHpCost.value = hs.inspect?.hpCost || 0;
    hotspotHpCostText.value = hs.inspect?.hpCostText || '';
    hotspotGives.value = hs.inspect?.givesItem||''; 
    hotspotRequires.value = hs.inspect?.requiresItem||''; 
    hotspotConsumes.checked = hs.inspect?.consumesItem === false ? false : true;
    hotspotGivesOnUse.value = hs.inspect?.givesItemOnUse||'';
    hotspotSuccessText.value = hs.inspect?.successText||''; 
    hotspotAlreadyInspectedText.value = hs.inspect?.alreadyInspectedText||'';
    hotspotOnSuccessScene.value = hs.inspect?.onSuccessScene||''; 
    
    const el = document.querySelector(`.editor-hotspot[data-id="${hotspotId}"]`);
    if (el) selectEditorHotspot(el);
  }

  hotspotForm.addEventListener('submit', async (e)=>{ 
    e.preventDefault(); 
    if(!adminSelectedSceneId) { await showNotify('씬을 선택하세요'); return; } 
    if(!tempHotspotData) { await showNotify('핫스팟을 먼저 선택/생성하세요'); return; } 
    
    const id=hotspotIdInput.value; 
    
    
    const area = tempHotspotData.area;

    
    tempHotspotData.label = hotspotLabel.value;
    tempHotspotData.sceneId = adminSelectedSceneId;
    tempHotspotData.inspect = {
        text:hotspotText.value||'', 
        inspectImgUrl:hotspotInspectImg.value||null, 
        hpCost: parseInt(hotspotHpCost.value, 10) || 0,
        hpCostText: hotspotHpCostText.value.trim() || null,
        givesItem:hotspotGives.value||null, 
        requiresItem:hotspotRequires.value||null, 
        consumesItem: hotspotConsumes.checked,
        givesItemOnUse: hotspotGivesOnUse.value || null,
        successText:hotspotSuccessText.value||'', 
        alreadyInspectedText: hotspotAlreadyInspectedText.value || null,
        onSuccessScene:hotspotOnSuccessScene.value||null 
    };

    
    gameData.hotspots[id] = tempHotspotData;
    
    
    tempHotspotData = null;

    closeHotspotForm(); 
    drawHotspotsInEditor(); 
    renderHotspotsForEditor(adminSelectedSceneId);
    await saveGameToFirestore();
  });

  if (btnDeleteHotspot) {
      btnDeleteHotspot.addEventListener('click', async ()=>{ 
        if(!adminSelectedHotspotId) return; 
        if(!(await showNotify('정말 삭제하시겠습니까?', '삭제 확인', 'confirm'))) return; 
        delete gameData.hotspots[adminSelectedHotspotId]; 
        adminSelectedHotspotId=null; 
        tempHotspotData=null; 
        closeHotspotForm(); 
        drawHotspotsInEditor(); 
        renderHotspotsForEditor(adminSelectedSceneId);
        await saveGameToFirestore();
      });
  }

  
  
  async function initPlayerMode(){ 
    hudUserId.textContent = currentPlayerId; 
    loadLocalPlayerState(); 
    await loadPlayerFromFirestore().catch(()=>{}); 

    
    if (playerState.hp === undefined) {
        playerState.hp = gameData.config?.startingHp || 100;
    }
    
    renderInventory(); 
    updateHpUI();
    
    const sceneToLoad = playerState.currentScene || gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0] || 'room';
    loadScene(sceneToLoad, false); 

    
    const savedVolume = localStorage.getItem('pnc_horror_bgm_volume');
    if (savedVolume) { 
        bgmVolume.value = savedVolume;
        bgmAudio.volume = savedVolume;
    }

    playerLoginForm.addEventListener('submit', async (e)=>{ 
      e.preventDefault(); 
      const newId = playerIdInput.value.trim(); 
      if(!newId) return; 
      currentPlayerId = newId; 
      hudUserId.textContent = currentPlayerId; 
      playerLoginModal.style.display='none'; 
      loadLocalPlayerState(); 
      await loadPlayerFromFirestore().catch(()=>{}); 
      
      if (playerState.hp === undefined) {
        playerState.hp = gameData.config?.startingHp || 100;
      }
      renderInventory(); 
      updateHpUI();
      const sceneToLoad = playerState.currentScene || gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0] || 'room';
      loadScene(sceneToLoad, false); 
    });

    
    adminLoginForm.addEventListener('submit', async (e)=>{ 
      e.preventDefault(); 
      
      const fixedEmail = 'test@gmail.com'; 
      loginErrorMsg.textContent = '로그인 중...'; 
      try{ 
        await signInWithEmailAndPassword(auth, fixedEmail, adminPasswordInput.value); 
        adminLoginModal.style.display='none'; 
        loginErrorMsg.textContent=''; 
      }catch(err){ 
        console.error(err); 
        loginErrorMsg.textContent='로그인 실패'; 
        adminPasswordInput.value=''; 
      } 
    });
    document.getElementById('btn-cancel-login').addEventListener('click', ()=>adminLoginModal.style.display='none');
    document.getElementById('btn-cancel-player').addEventListener('click', ()=>playerLoginModal.style.display='none');
  }

  function loadScene(sceneId,withFade=true){ 
    const scene = gameData.scenes[sceneId]; 
    if(!scene){ 
        const first = gameData.sceneOrder[0] || Object.keys(gameData.scenes)[0]; 
        if(first) { 
            playerState.currentScene = first; 
            saveLocalPlayerState(); 
            loadScene(first,withFade); 
        } 
        return; 
    }
    playerState.currentScene = sceneId; 
    saveLocalPlayerState(); 
    savePlayerToFirestore(); 
    hudScene.textContent = `${scene.title} (${sceneId})`; 
    
    
    playBgm(scene.bgmUrl || gameData.config.bgmUrl);
    
    if(withFade){ 
        document.getElementById('fade').style.opacity='1'; 
        setTimeout(()=>applyScene(scene),450); 
    } else {
        applyScene(scene);
    }
    updateHpUI();
  }

  

  function applyScene(scene){ 
    sceneBg.style.backgroundImage = `url('${scene.backgroundUrl}')`; 
    hotspotLayer.innerHTML=''; 
    setTimeout(()=>{ 
        const containerW = document.getElementById('game').clientWidth; 
        const containerH = document.getElementById('game').clientHeight; 
        
        Object.values(gameData.hotspots).filter(hs=>hs.sceneId===scene.id).forEach(hs=>{ 
            const el=document.createElement('div'); 
            el.className='hotspot'; 
            el.dataset.id=hs.id; 
            
            const x = hs.area.x * containerW; 
            const y = hs.area.y * containerH; 
            const w = hs.area.w * containerW; 
            const h = hs.area.h * containerH; 
            
            el.style.left=`${x}px`; 
            el.style.top=`${y}px`; 
            el.style.width=`${w}px`; 
            el.style.height=`${h}px`; 
            el.title = hs.label || hs.id; 
            
            el.addEventListener('click',(ev)=>{ ev.stopPropagation(); onHotspotClick(hs); }); 
            hotspotLayer.appendChild(el); 
        }); 
        document.getElementById('fade').style.opacity='0'; 
    }, (document.body.dataset.mode === 'admin') ? 0 : 50); 
    updateHpUI();
  }

  
  function updateChoicePopupVisibility() {
      const buttons = [btnInspect, btnUseItem, btnMoveFromSuccess];
      
      const anyButtonVisible = buttons.some(btn => btn.style.display !== 'none');
      
      if (anyButtonVisible) {
          choicePopup.classList.add('show');
      } else {
          choicePopup.classList.remove('show');
      }
  }

  
  function onHotspotClick(hs){ 
    if (isIntroPlaying) return;
    currentHotspot = hs; 
    popupTitle.textContent = hs.label||'조사'; 
    popupHotspotLabelEl.textContent = hs.label || '';
    
    const ins = hs.inspect || {};
    const hpCost = ins.hpCost || 0;
    const gives = ins.givesItem; 
    const requires = ins.requiresItem; 
    const onSuccess = ins.onSuccessScene;
    
    const isUnlocked = !!playerState.unlockedHotspots[hs.id]; 
    const hasBeenHPDrained = !!playerState.inspectedHotspots[hs.id];
    
    
    const oldImg = document.getElementById('popupImg'); 
    if(oldImg) oldImg.remove();
    
    const imgSrc = ins.inspectImgUrl;
    if (imgSrc) { 
        const img = document.createElement('img'); 
        img.id = 'popupImg'; 
        img.src = imgSrc; 
        inspectPopup.insertBefore(img, inspectPopup.firstChild);
    }
    
    
    btnInspect.style.display='none';
    btnUseItem.style.display='none';
    btnMoveFromSuccess.style.display = 'none';
    
    let isLocked = false;
    let mainText = ins.text||'아무 것도 없다.';
    
    if(isUnlocked) {
        
        if (onSuccess) { 
             btnMoveFromSuccess.style.display = 'inline-block';
             btnMoveFromSuccess.textContent = '이동';
            
             btnMoveFromSuccess.onclick = ()=>{
                playerState.selectedItem=null; 
                closePopup();
                loadScene(onSuccess); 
                saveLocalPlayerState(); 
                savePlayerToFirestore(); 
             };
        } else {
        }
        
        mainText = ins.alreadyInspectedText || ins.successText || '더 이상 특별한 것은 없다.';

    } else if(requires){
        
        isLocked = true;
        mainText += '\n\n주변을 둘러보자. 도움이 될 만한 게 있을지도 모른다.';
    } else if(gives || onSuccess || (hpCost > 0 && !hasBeenHPDrained)) {
        
        btnInspect.style.display = 'inline-block';
        btnInspect.textContent = '조사'; 
        mainText = ins.text||'새로운 것을 찾은 것 같다. 조사해보자.'; 
    } else {
    }

    
    const itemName = playerState.selectedItem ? (gameData.items[playerState.selectedItem]?.name || playerState.selectedItem) : '';

    if(isLocked && playerState.selectedItem){
        if (playerState.selectedItem === requires) {
            
            btnUseItem.style.display = 'inline-block';
            btnUseItem.textContent = '아이템 사용';
            mainText = `[${itemName}](을)를 사용할 수 있다.`;
            btnInspect.style.display = 'none'; 
        } else {
            
            mainText = `[${itemName}](을)를 사용할 수 없다.`;
            btnUseItem.style.display = 'none';
            btnInspect.style.display = 'none';
        }
    }

    stopTypewriter();
    popupContinueEl.style.display = 'none';
    paginateText(mainText);

    document.getElementById('inspectPopup').classList.add('show'); 
    
    updateChoicePopupVisibility();
  }

  function closePopup(){ 
    document.getElementById('inspectPopup').classList.remove('show'); 
    choicePopup.classList.remove('show');
    currentHotspot=null; 
    
    const oldImg = document.getElementById('popupImg'); 
    if(oldImg) oldImg.remove();
    
    stopTypewriter();
    popupContinueEl.style.display = 'none';
    popupHotspotLabelEl.textContent = '';
    popupText.textContent = '';
  }
  
  
  async function onInspectClickLogic(){ 
    if(!currentHotspot) return; 
    
    playSound(gameData.config.inspectSfxUrl);
    
    const hs = currentHotspot;
    const ins = hs.inspect||{};
    
    const hpCost = ins.hpCost || 0;
    const hasBeenHPDrained = !!playerState.inspectedHotspots[hs.id];
    
    
    if (hpCost > 0 && !hasBeenHPDrained) {
        playerState.inspectedHotspots[hs.id] = true; 
        
        if (ins.hpCostText) {
            await showNotify(ins.hpCostText, '알림');
        }
        
        playerState.hp -= hpCost;
        if (playerState.hp < 0) playerState.hp = 0;
        
        updateHpUI();
        
        await showNotify(`HP가 ${hpCost}만큼 감소했습니다.\n(현재 HP: ${playerState.hp} / ${gameData.config?.startingHp || 100})`, '체력 감소');
        
        if (playerState.hp === 0) {
            closePopup();
            handleGameOver();
            return; 
        }
    }
    
    
    const gives = ins.givesItem; 
    const onSuccess = ins.onSuccessScene;
    
    
    if(!playerState.unlockedHotspots[hs.id]){ 
        if(gives){
            giveItemToPlayer(gives); 
        }
        
        
        if(gives || onSuccess || (hpCost > 0 && !hasBeenHPDrained)) {
            playerState.unlockedHotspots[hs.id]=true; 
        }

        if(gives || onSuccess || hpCost > 0){
            saveLocalPlayerState(); 
            savePlayerToFirestore(); 
        }
    }
    
    
    let successMessage = ins.successText||'';
    if (gives && !successMessage) {
         successMessage = `${gameData.items[gives]?.name || gives}(을)를 발견했다.`;
    } else if (!successMessage) {
        successMessage = (hpCost > 0) ? '더 이상 특별한 것은 없다.' : '문제가 해결되었다.';
    }
    
    stopTypewriter();
    paginateText(successMessage); 

    
    btnInspect.style.display = 'none'; 
    btnUseItem.style.display='none'; 

    if(onSuccess){
        
        btnMoveFromSuccess.style.display = 'inline-block';
        btnMoveFromSuccess.textContent = '이동';
        
        btnMoveFromSuccess.onclick = ()=>{
            playerState.selectedItem=null; 
            closePopup();
            loadScene(onSuccess); 
            saveLocalPlayerState(); 
            savePlayerToFirestore(); 
        };
    }
    
    updateChoicePopupVisibility();
  }

  
  function onUseItemClick(){ 
    if(!currentHotspot || !playerState.selectedItem) return; 
    const hs = currentHotspot;
    const ins=hs.inspect||{}; 
    const required = ins.requiresItem; 
    
    if(required && required===playerState.selectedItem){ 
      
      const itemDef = gameData.items[playerState.selectedItem];
      const itemName = itemDef ? itemDef.name : playerState.selectedItem;
      const defaultSuccessText = `[${itemName}](을)를 사용했다.`;
      let successText = ins.successText || defaultSuccessText; 
      
      playerState.unlockedHotspots[hs.id]=true; 
      
      const givesOnUse = ins.givesItemOnUse;
      if (givesOnUse) {
          giveItemToPlayer(givesOnUse);
          successText += ` (${gameData.items[givesOnUse]?.name || givesOnUse} 획득)`;
      }
      
      stopTypewriter();
      paginateText(successText);
      
      playerState.selectedItem=null; 
      
      const consumes = ins.consumesItem === false ? false : true;
      if (consumes) {
          if (playerState.inventory[required] > 0) {
              playerState.inventory[required]--;
              if (playerState.inventory[required] === 0) {
                  delete playerState.inventory[required];
              }
          }
      }

      saveLocalPlayerState(); 
      savePlayerToFirestore(); 
      renderInventory(); 
      
      btnInspect.style.display = 'none';
      btnUseItem.style.display = 'none';
      
      if(ins.onSuccessScene){ 
        btnMoveFromSuccess.style.display = 'inline-block';
        btnMoveFromSuccess.textContent = '이동';
        
        btnMoveFromSuccess.onclick = ()=>{
            playerState.selectedItem=null; 
            closePopup();
            loadScene(ins.onSuccessScene); 
            saveLocalPlayerState(); 
            savePlayerToFirestore(); 
        };

      } else { 
      } 
      
      updateChoicePopupVisibility();
    } else { 
      const itemDef = gameData.items[playerState.selectedItem];
      const itemName = itemDef ? itemDef.name : playerState.selectedItem;
      
      stopTypewriter();
      paginateText(`[${itemName}](이)가 여기에 작동하지 않는다.`);
      updateChoicePopupVisibility();
    } 
  }

  function renderInventory(){ 
    invPanel.innerHTML=''; 
    const inv = playerState.inventory||{}; 
    const keys = Object.keys(inv).filter(id => (inv[id] || 0) > 0); 
    
    if(keys.length===0){ 
      invPanel.innerHTML='<div style="color:#666;padding:6px 8px;user-select:none;font-size:12px;">(비어있음)</div>'; 
      return; 
    } 
    
    keys.forEach(id=>{ 
      const count = inv[id]; 
      const def = gameData.items[id]||{name:id,imgUrl:'',description:'정보 없음'}; 
      const slot=document.createElement('div'); 
      slot.className='inv-slot'; 
      slot.dataset.item=id; 
      
      if(playerState.selectedItem===id) slot.classList.add('selected'); 
      
      const img=document.createElement('img'); 
      img.src = def.imgUrl; 
      img.alt = def.name; 
      slot.appendChild(img); 
      slot.title = def.name; 
      
      if(count>1){ 
        const c=document.createElement('div'); 
        c.style.position='absolute'; 
        c.style.right='4px'; 
        c.style.bottom='4px'; 
        c.style.fontSize='10px'; 
        c.style.color='white';
        c.style.backgroundColor='black';
        c.style.padding='0 2px';
        c.style.border='1px solid white';
        c.textContent = count; 
        slot.appendChild(c); 
      } 
      
      slot.addEventListener('click',(e)=>{ 
        e.stopPropagation(); 
        
        if (playerState.selectedItem === id) {
             
             showItemInfoPopup(id);
             
             
        } else {
             
             playerState.selectedItem = id;
        }

        saveLocalPlayerState(); 
        savePlayerToFirestore(); 
        renderInventory(); 
        if(currentHotspot) onHotspotClick(currentHotspot);
      }); 
      invPanel.appendChild(slot); 
    }); 
  }
  
  function giveItemToPlayer(itemId,count=1){ 
    const inv = playerState.inventory||{};
    const hasItem = (inv[itemId] || 0) > 0;
    
    if (!hasItem) {
        const keys = Object.keys(inv).filter(id => (inv[id] || 0) > 0);
        const uniqueItemCount = keys.length;
        
        if (uniqueItemCount >= 4) {
            showNotify('인벤토리가 가득 찼습니다. (최대 4종류)', '알림');
            return;
        }
    }
  
    playerState.inventory[itemId] = (playerState.inventory[itemId]||0)+count; 
    
    const def = gameData.items[itemId];
    if (def && def.itemType === 'healing') {
        if (!playerState.itemState[itemId]) {
            playerState.itemState[itemId] = { totalUses: 0 };
        }
        playerState.itemState[itemId].totalUses += (def.uses || 1) * count;
    }
    
    saveLocalPlayerState(); 
    savePlayerToFirestore(); 
    renderInventory(); 
  }

  function showItemInfoPopup(itemId) {
    const def = gameData.items[itemId]||{name:itemId, description:'정보 없음'};
    itemInfoTitle.textContent = def.name;
    itemInfoText.textContent = def.description;
    
    itemInfoHealingDetails.style.display = 'none';
    btnItemInfoUse.style.display = 'none';
    btnItemInfoUse.onclick = null;
    
    btnItemInfoDrop.style.display = 'inline-block';
    btnItemInfoDrop.dataset.itemId = itemId;

    if (def.itemType === 'healing') {
        const itemState = playerState.itemState[itemId] || { totalUses: 0 };
        const maxHp = gameData.config?.startingHp || 100;
        
        itemInfoHealAmount.textContent = def.healAmount || 0;
        itemInfoUses.textContent = itemState.totalUses;
        itemInfoHealingDetails.style.display = 'block';

        if (itemState.totalUses > 0 && playerState.hp < maxHp) {
            btnItemInfoUse.style.display = 'inline-block';
            btnItemInfoUse.onclick = () => useHealingItem(itemId);
        }
    }

    document.getElementById('item-info-modal').style.display = 'flex';
  }
  
  async function onItemDropClick() {
      const itemId = btnItemInfoDrop.dataset.itemId;
      if (!itemId) return;

      const def = gameData.items[itemId] || { name: itemId };
      
      
      itemInfoModal.style.display = 'none';
      
      const confirmed = await showNotify(
          `정말로 [${def.name}] 아이템을 버리시겠습니까?\n이 아이템은 영구히 사라집니다.`,
          '아이템 버리기 확인',
          'confirm'
      );

      if (confirmed) {
          
          if (playerState.inventory[itemId]) {
              delete playerState.inventory[itemId];
          }
          
          
          if (playerState.itemState[itemId]) {
              delete playerState.itemState[itemId];
          }

          
          if (playerState.selectedItem === itemId) {
              playerState.selectedItem = null;
          }

          
          saveLocalPlayerState();
          savePlayerToFirestore();
          renderInventory();
          
          
          showNotify(`[${def.name}] 아이템을 버렸습니다.`, '알림');
      } else {
          
          itemInfoModal.style.display = 'flex';
      }
  }
  
  function useHealingItem(itemId) {
    const def = gameData.items[itemId];
    const itemState = playerState.itemState[itemId];
    const maxHp = gameData.config?.startingHp || 100;
    
    if (!def || !itemState || itemState.totalUses <= 0 || playerState.hp >= maxHp) {
        return;
    }
    
    
    itemState.totalUses--;
    
    
    const usesPerItem = def.uses || 1;
    
    if ((itemState.totalUses % usesPerItem) === 0) {
        playerState.inventory[itemId]--;
        if (playerState.inventory[itemId] === 0) {
            delete playerState.inventory[itemId];
        }
    }
    
    
    const oldHp = playerState.hp;
    playerState.hp = Math.min(maxHp, playerState.hp + def.healAmount);
    const healedAmount = playerState.hp - oldHp;
    
    updateHpUI();
    saveLocalPlayerState();
    savePlayerToFirestore();
    
    
    itemInfoModal.style.display = 'none';
    showNotify(`HP가 ${healedAmount}만큼 회복되었습니다.\n(현재 HP: ${playerState.hp} / ${maxHp})`, '아이템 사용');
    
    
    if (playerState.selectedItem === itemId) {
        playerState.selectedItem = null;
    }
    renderInventory();
  }

  window.addEventListener('click', (e)=>{ 
    
    if (!document.getElementById('inspectPopup').classList.contains('show')) {
      return;
    }
    
    
    if (document.getElementById('inspectPopup').contains(e.target) || document.getElementById('choicePopup').contains(e.target) ) {
      return;
    }
    
    
    
    if (isIntroPlaying) {
        return; 
    }
    
    
    closePopup(); 
  });
  
  async function toggleSceneSelectMode(e) {
      const btn = e.target;
      const list = sceneList;
      const isSelectMode = list.classList.contains('select-mode');

      if (isSelectMode) {
          
          await onDeleteSelectedScenesClick();
      } else {
          
          list.classList.add('select-mode');
          btn.textContent = 'Delete Selected';
      }
  }
  
  async function toggleHotspotSelectMode(e) {
      const btn = e.target;
      const listContainer = hotspotListContainer;
      const isSelectMode = listContainer.classList.contains('select-mode');
      
      if (isSelectMode) {
          await onDeleteSelectedHotspotsClick();
      } else {
          listContainer.classList.add('select-mode');
          btn.textContent = 'Delete Selected';
      }
  }
  
  async function toggleItemSelectMode(e) {
      const btn = e.target;
      const list = itemList;
      const isSelectMode = list.classList.contains('select-mode');
      
      if (isSelectMode) {
          await onDeleteSelectedItemsClick();
      } else {
          list.classList.add('select-mode');
          btn.textContent = 'Delete Selected';
      }
  }
            
  async function onDeleteSelectedScenesClick() {
      const selectedIds = Array.from(document.querySelectorAll('.scene-select-cb:checked'))
                             .map(cb => cb.dataset.sceneId);
      
      if (selectedIds.length === 0) {
          await showNotify('삭제할 씬을 하나 이상 선택하세요.', '알림');
          return; 
      }

      const totalScenes = gameData.sceneOrder.length;
      if (selectedIds.length >= totalScenes) {
          await showNotify('씬은 최소 한 개 이상 존재해야 합니다. 모든 씬을 삭제할 수 없습니다.', '삭제 불가');
          return; 
      }

      const sceneNames = selectedIds.map(id => gameData.scenes[id]?.title || id).join(', ');
      const confirmed = await showNotify(
          `선택한 ${selectedIds.length}개의 씬 (${sceneNames})(을)를 정말 삭제하시겠습니까? (저장하지 않으면 복구 가능)`,
          '선택한 씬 삭제 확인',
          'confirm'
      );

      if (confirmed) {
          let deletedCount = 0;
          selectedIds.forEach(sceneId => {
              if (gameData.sceneOrder.length > 1) {
                  delete gameData.scenes[sceneId];
                  gameData.sceneOrder = gameData.sceneOrder.filter(id => id !== sceneId);
                  Object.keys(gameData.hotspots).forEach(hsId => {
                      if (gameData.hotspots[hsId].sceneId === sceneId) {
                          delete gameData.hotspots[hsId];
                      }
                  });
                  deletedCount++;
              }
          });

          if (deletedCount > 0) {
              renderAdminLists();
              if (adminSelectedSceneId && selectedIds.includes(adminSelectedSceneId)) {
                   btnClearSceneForm.click();
              }
              await saveGameToFirestore();
              await showNotify(`${deletedCount}개의 씬을 삭제했습니다.`, '삭제 완료');
              
              
              sceneList.classList.remove('select-mode');
              btnToggleSceneSelect.textContent = 'Select';
          }
      }
      
  }

  async function onDeleteSelectedHotspotsClick() {
      if (!adminSelectedSceneId) {
          await showNotify('씬이 선택되지 않았습니다.', '알림');
          return; 
      }
      
      const selectedIds = Array.from(hotspotListContainer.querySelectorAll('.hotspot-select-cb:checked'))
                             .map(cb => cb.dataset.hotspotId);
      
      if (selectedIds.length === 0) {
          await showNotify('삭제할 핫스팟을 하나 이상 선택하세요.', '알림');
          return; 
      }

      const hotspotNames = selectedIds.map(id => gameData.hotspots[id]?.label || id).join(', ');
      const confirmed = await showNotify(
          `선택한 ${selectedIds.length}개의 핫스팟 (${hotspotNames})(을)를 정말 삭제하시겠습니까?`,
          '선택한 핫스팟 삭제 확인',
          'confirm'
      );

      if (confirmed) {
          let wasFormClosed = false;
          selectedIds.forEach(hsId => {
              delete gameData.hotspots[hsId];
              if (adminSelectedHotspotId === hsId) {
                  closeHotspotForm();
                  wasFormClosed = true;
              }
          });
          
          drawHotspotsInEditor();
          renderHotspotsForEditor(adminSelectedSceneId);
          await saveGameToFirestore();
          await showNotify(`${selectedIds.length}개의 핫스팟을 삭제했습니다.`, '삭제 완료');
          
          
          hotspotListContainer.classList.remove('select-mode');
          btnToggleHotspotSelect.textContent = 'Select';
      }
      
  }
  
  async function onDeleteSelectedItemsClick() {
      const selectedIds = Array.from(itemList.querySelectorAll('.item-select-cb:checked'))
                             .map(cb => cb.dataset.itemId);
      
      if (selectedIds.length === 0) {
          await showNotify('삭제할 아이템을 하나 이상 선택하세요.', '알림');
          return; 
      }

      const itemNames = selectedIds.map(id => gameData.items[id]?.name || id).join(', ');
      const confirmed = await showNotify(
          `선택한 ${selectedIds.length}개의 아이템 (${itemNames})(을)를 정말 삭제하시겠습니까?`,
          '선택한 아이템 삭제 확인',
          'confirm'
      );

      if (confirmed) {
          selectedIds.forEach(id => {
              delete gameData.items[id];
              
              
          });
          
          renderAdminLists(); 
          await saveGameToFirestore();
          await showNotify(`${selectedIds.length}개의 아이템을 삭제했습니다.`, '삭제 완료');
          
          
          itemList.classList.remove('select-mode');
          btnToggleItemSelect.textContent = 'Select';
      }
      
  }

  init();

</script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</body>
</html>
