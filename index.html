<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tistory용 공포 쯔꾸르 (확장 관리자판, Firebase 통합)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&display=swap');
  :root{
    --bg:#000;
    --panel:rgba(0,0,0,0.85);
    --accent:#c0392b;
    --border-dark:#222;
    --border-light:#444;
    --text-color:#eee;
    --input-bg:#1a1a1a;
    --panel-width: 250px; 
    --main-width: 640px; 
    --main-height: 480px; 
  }
  body{
    margin:0;background:var(--bg);color:var(--text-color);font-family:'Noto Sans KR',sans-serif;
    display:flex;flex-direction:row;align-items:center;justify-content:center;height:100vh;overflow:hidden;
    gap: 10px; 
  }
  #topBar{
    display:flex;justify-content:space-between;width:100%;padding:8px 16px;position:fixed;top:0;right:0;left:0;
    z-index:20;background:var(--panel);box-shadow: 0 2px 5px rgba(0,0,0,0.5);height: 40px;align-items: center;box-sizing: border-box;
  }
  #topBarControls { display: flex; gap: 10px; align-items: center; } 
  #bgmControls { display:flex;gap:10px;align-items:center;flex-shrink:0; }
  #bgmControls button, #adminBtn, #playerLoginBtnTop { padding:5px 10px;font-size:14px;line-height:1;height:30px; }
  #bgmVolume { width:80px;height:4px;background:var(--border-light);-webkit-appearance:none;appearance:none;border-radius:5px;cursor:pointer; }
  #bgmVolume::-webkit-slider-thumb {-webkit-appearance:none;appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer;box-shadow:0 0 5px var(--accent);}
  
  /* --- Side Panels: Log/Chat (Left) & Status/Inventory (Right) --- */
  .side-panel {
    width: var(--panel-width);
    height: var(--main-height); 
    background: var(--panel);
    border: 1px solid var(--border-light);
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    z-index: 5;
  }
  
  /* Log/Chat Panel: **[수정]** 로그인 전 기본 숨김 */
  #logChatPanel { order: 1; display: none; }
  
  /* **[수정]** 채팅창 스크롤: 가로 스크롤 방지, 세로 스크롤 허용 */
  #logDisplay {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden; /* 가로 스크롤 명시적으로 숨김 */
    background: var(--input-bg);
    padding: 8px;
    margin-bottom: 10px;
    border-radius: 4px;
    border: 1px solid var(--border-dark);
    word-wrap: break-word; /* 텍스트 줄바꿈 */
    overflow-wrap: break-word; /* 텍스트 줄바꿈 */
  }
  
  .log-item, .chat-item { 
    font-size: 13px; 
    line-height: 1.4; 
    padding: 2px 0; 
    border-bottom: 1px dotted rgba(255,255,255,0.05); 
    white-space: normal; /* 줄바꿈 허용 */
    word-break: break-all; /* 단어가 길어도 강제 줄바꿈 */
  }
  
  /* **[수정]** 채팅창 알림(시스템)은 노란색, 플레이어/관리자 채팅 내용은 흰색 */
  .log-item.system { color: #f1c40f; } /* 노란색 */
  .log-item.item { color: #2ecc71; }
  .chat-item { color: var(--text-color); } /* 플레이어 채팅 (흰색) */
  .chat-item.admin { color: var(--text-color); font-weight: bold; } /* 관리자 채팅 (흰색으로 변경) */
  
  .chat-input-group { display: flex; gap: 5px; }
  .chat-input-group input { flex-grow: 1; }
  .chat-input-group button { flex-shrink: 0; padding: 5px 10px; }
  
  /* Log/Chat Panel UI & Layout Fixes */
  .chat-controls { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-bottom: 5px;
      gap: 5px; 
  }
  
  #logChatPanel .chat-controls button {
      width: 30px; 
      height: 30px; 
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px; 
      line-height: 1;
      flex-shrink: 0;
  }
  #logToggleBtn { 
      font-size: 18px; 
      margin-right: 5px; 
  } 

  .chat-controls > div {
      display: flex; 
      align-items: center; 
      flex-grow: 1; 
      min-width: 50px; 
  }

  .chat-controls #chatNickname {
      width: 100%; 
      padding: 5px; 
      margin: 0; 
      box-sizing: border-box; 
  }

  .chat-item span.admin-actions { margin-left: auto; display: none; } 
  .chat-item span.admin-actions button { margin-left: 5px; padding: 2px 5px; font-size: 10px; }

  /* Status/Inventory Panel (Right Panel) */
  #statusInventoryPanel { order: 3; display: none; } /* **[수정]** 기본 숨김 */
  
  /* Player Content */
  #playerContent { display: flex; flex-direction: column; flex-grow: 1; }
  #playerStatus {
      padding: 5px;
      border-bottom: 1px solid var(--border-dark);
      margin-bottom: 10px;
  }
  #playerHP { font-size: 16px; font-weight: bold; color: var(--accent); }
  #inventoryList {
      flex-grow: 1;
      overflow-y: auto;
      padding: 5px;
  }
  .inventory-item { 
      display: flex;
      gap: 10px;
      padding: 8px;
      margin-bottom: 5px;
      background: var(--input-bg);
      border-radius: 4px;
      border: 1px solid var(--border-dark);
      align-items: center;
      cursor: pointer;
  }
  .inventory-item:hover { background: #2a2a2a; }
  .item-name { font-weight: bold; font-size: 14px; }
  .item-image { width: 40px; height: 40px; object-fit: cover; border-radius: 3px; border: 1px solid var(--accent); }
  .item-desc { font-size: 12px; color: #aaa; }

  /* Admin Info Content **[수정]** 깔끔하게 재정렬 및 플레이어 정보 추가 */
  #adminRightInfo { 
      padding: 5px; 
      flex-grow: 1; 
      font-size: 14px; 
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
  }
  #adminRightInfo h4 { 
      width: 100%; 
      margin-top: 0; 
      border-bottom: 1px solid var(--border-dark); 
      padding-bottom: 8px; 
      color: var(--accent); 
  }
  #adminRightInfo p { 
      margin-bottom: 8px; 
      line-height: 1.5;
      flex-shrink: 0; 
  }
  #adminRightInfo hr {
      width: 100%;
      margin: 15px 0;
  }
  #playerOnMapList {
      flex-grow: 1;
      overflow-y: auto;
      margin-top: 5px;
      padding: 5px;
      background: var(--input-bg);
      border-radius: 4px;
      border: 1px solid var(--border-dark);
  }
  .player-on-map-item {
      padding: 5px 0;
      border-bottom: 1px dashed rgba(255,255,255,0.1);
      line-height: 1.4;
  }
  .player-on-map-item:last-child { border-bottom: none; }
  .player-on-map-item strong { color: #5dade2; } 
  .player-on-map-item small { display: block; color: #aaa; font-size: 11px; margin-left: 5px; }
  
  #container{
    order: 2; 
    position:relative;width:var(--main-width);height:var(--main-height);overflow:hidden;border:3px solid var(--border-light);
    box-shadow:0 0 40px var(--accent);background:#000;z-index:5;
  }
  canvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block;z-index:1}
  #grid{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:2}
  #dragGhost { position:absolute;width:32px;height:32px;background:rgba(0,255,255,0.4);border:2px solid cyan;pointer-events:none;display:none;z-index:4; }
  
  /* Admin Panel tabs */
  #adminPanel{
    position:fixed; 
    right: 20px; 
    top: 60px;
    z-index:15;background:var(--panel);padding:15px;border-radius:10px;
    font-size:14px;display:none;min-width:400px;max-width:400px;border:1px solid var(--accent);
    box-shadow:0 0 10px rgba(192,57,43,0.5);max-height: calc(100vh - 80px);overflow-y: auto;
    transition: width 0.3s, height 0.3s, padding 0.3s, overflow 0.3s; 
  }

  /* --- 스크롤바 디자인 통일 --- */
  #adminPanel, #editModal .modal, #choices, #logDisplay, #inventoryList { 
      scrollbar-width: thin; 
      scrollbar-color: var(--accent) rgba(0,0,0,0.2); 
  }
  #adminPanel::-webkit-scrollbar, 
  #editModal .modal::-webkit-scrollbar, 
  #choices::-webkit-scrollbar, 
  #logDisplay::-webkit-scrollbar,
  #inventoryList::-webkit-scrollbar { 
      width: 8px; 
  }
  #adminPanel::-webkit-scrollbar-thumb, 
  #editModal .modal::-webkit-scrollbar-thumb, 
  #choices::-webkit-scrollbar-thumb, 
  #logDisplay::-webkit-scrollbar-thumb,
  #inventoryList::-webkit-scrollbar-thumb { 
      background-color: var(--accent); 
      border-radius: 4px; 
      visibility: hidden; 
  }
  #adminPanel:hover::-webkit-scrollbar-thumb, 
  #editModal .modal:hover::-webkit-scrollbar-thumb, 
  #choices:hover::-webkit-scrollbar-thumb, 
  #logDisplay:hover::-webkit-scrollbar-thumb,
  #inventoryList:hover::-webkit-scrollbar-thumb { 
      visibility: visible; 
  }
  #adminPanel::-webkit-scrollbar-track,
  #editModal .modal::-webkit-scrollbar-track,
  #choices::-webkit-scrollbar-track,
  #logDisplay::-webkit-scrollbar-track,
  #inventoryList::-webkit-scrollbar-track { 
      background: rgba(0,0,0,0.2); 
  }
  /* --- 스크롤바 끝 --- */
  
  /* Drag handle style */
  #adminPanel h4{
      margin:0 0 12px 0;text-align:center;color:var(--accent);border-bottom: 1px solid var(--border-dark);padding-bottom: 8px;
      cursor: grab; 
      display: flex;
      justify-content: space-between;
      align-items: center;
  }
  /* Minimize button style */
  #minimizeBtn {
      background: none;
      border: none;
      color: var(--accent);
      padding: 0 5px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      transition: color 0.2s;
      margin-left: 10px;
  }
  #minimizeBtn:hover { color: #fff; }

  /* Minimized State */
  #adminPanel.minimized {
    width: 150px;
    min-width: 150px;
    height: auto; 
    max-height: 50px;
    padding: 10px 15px;
    overflow: hidden;
    right: 20px !important; 
    left: auto !important;
    top: 60px !important;
  }
  #adminPanel.minimized h4 {
    margin: 0;
    padding: 0;
    border-bottom: none;
  }
  #adminPanel.minimized #minimizeBtn {
      margin-left: 0;
  }
  #adminPanel.minimized .admin-tabs,
  #adminPanel.minimized .admin-tab-content {
    display: none !important;
  }

  
  .admin-tabs { display: flex; margin-bottom: 15px; border-bottom: 1px solid var(--border-dark); }
  .admin-tabs button { flex: 1; padding: 10px 5px; background: var(--border-dark); border: none; border-radius: 4px 4px 0 0; color: var(--text-color); cursor: pointer; transition: background 0.2s; }
  .admin-tabs button:not(.active):hover { background: #444; }
  .admin-tabs button.active { background: var(--accent); color: #fff; border-bottom: 1px solid var(--accent); }
  
  .admin-tab-content { display: none; }
  .admin-tab-content.active { display: block; }
  
  /* Existing Admin Panel styles */
  .row{display:flex;gap:10px;align-items:center;margin-bottom:10px;width:100%;}
  .row label{white-space:nowrap;min-width: 60px;}
  hr {border: none;border-top: 1px dashed var(--border-dark);margin: 15px 0;}
  input[type=text], input[type=password], input[type=number], select, textarea{
    background:var(--input-bg);border:1px solid var(--border-dark);padding:8px;border-radius:4px;
    color:var(--text-color);width:100%;box-sizing:border-box;transition: border-color 0.2s;
  }
  input:focus, select:focus, textarea:focus { border-color: var(--accent);outline: none;}
  button{
    background:var(--border-dark);border:1px solid var(--border-light);color:var(--text-color);
    padding:8px 12px;border-radius:4px;cursor:pointer;white-space:nowrap;
    transition: background 0.2s, color: 0.2s;text-align: center;
  }
  button:hover{background:var(--accent);border-color:var(--accent);color:#fff;}
  #toggleGrid.active, #toggleEncounter.active, #toggleImpassable.active {background: var(--accent);border-color: var(--accent);color: #fff;}
  
  /* [1. 로드/그리드/조우/제한 버튼 컨테이너 가로 넓이 균등 분배] */
  .control-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      width: 100%;
  }
  .control-group button {
      flex: 1; /* 모든 버튼이 동일한 비율로 확장 */
      min-width: 0;
  }
  
  #adminPanel > .row:first-of-type #mapName {flex-grow: 1;}
  #adminPanel > .row:first-of-type #saveMap {flex-grow: 1;width: auto;flex-shrink: 1;}
  #mapButtons {display: block !important;}
  
  /* [2. 조우/제한 전체 삭제 버튼 제거로 인한 레이아웃 수정] */
  #mapButtons > div {display: flex;gap: 10px;margin-bottom: 5px;width: 100%;}
  #mapButtons > div button {
      flex-grow: 1; 
      min-width: 0;
  }

  /* Map List Item Style */
  .map-list-item { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      padding: 8px; 
      border-bottom: 1px dashed var(--border-dark); 
      cursor: pointer;
      transition: background 0.2s;
  }
  .map-list-item:hover { 
      background: rgba(192, 57, 43, 0.1); 
  }
  .map-list-item span { 
      font-weight: bold; 
      color: var(--text-color);
  }
  .map-list-item:last-child { border-bottom: none; }
  .map-list-item button { 
      padding: 4px 8px; 
      font-size: 11px;
      background: #550000;
      border-color: #770000;
  }
  
  /* Login Boxes - FIXED CSS */
  #loginBox, #playerLoginBox {
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.8); 
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center; 
    z-index:25; 
  }
  #loginBox .modal, #playerLoginBox .modal {
    background:var(--panel);padding:20px;
    border-radius:8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.8);border:1px solid var(--border-light);
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  #loginBox div, #playerLoginBox div {font-size: 1.1em;margin-bottom: 10px;}
  #loginBox input, #playerLoginBox input{ margin-top:8px;padding:10px;border-radius:4px;border:none;background:#2a2a2a;color:#fff;width:220px;text-align:center; }
  #loginBox button, #playerLoginBox button{ margin-top:15px;padding:10px 20px;background:var(--accent);color:#fff;border:none;border-radius:4px; }
  #loginBox button:hover, #playerLoginBox button:hover{background: #e74c3c;}
  
  /* User/Item List Styles */
  .list-container { max-height:250px;overflow-y:auto;padding:8px;background:rgba(255,255,255,0.05); border-radius:4px;margin-top:10px;border: 1px solid var(--border-dark); }
  .list-item{ display:flex;justify-content:space-between;gap:8px;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.05);font-size:13px;align-items:center; }
  .list-item:last-child {border-bottom: none;}
  .list-item > span {flex-grow: 1;}
  .list-item div {display: flex;gap: 5px;}
  .list-item button {padding: 4px 8px;font-size: 12px;}
  .list-item button.del {background: #550000;border-color: #770000;}
  .list-item button.del:hover {background: #e74c3c;}
  .list-item input[type=text], .list-item input[type=number] { margin: 0; padding: 4px; height: auto; font-size: 12px; }

  /* Modal Styles */
  .modal-bg{position:fixed;inset:0;background:rgba(0,0,0,0.9);display:none;align-items:center;justify-content:center;z-index:30;}
  .modal{background:#111;padding:15px;border-radius:10px;min-width:450px;max-width: 600px; width: auto;color:var(--text-color);box-sizing:border-box;border:2px solid var(--accent);box-shadow: 0 0 15px rgba(192, 57, 43, 0.7);}
  
  /* 조우 팝업 내 스크롤 튀어나옴 문제 수정 */
  #editModal .modal { 
      min-width: 600px; 
      max-width: 800px; 
      width: 70vw; 
      overflow-y: auto; 
      max-height: 90vh; 
  }
  
  #editModal .modal h4 { margin-top: 5px; margin-bottom: 8px; }
  .modal label { display: block; margin-top: 8px; margin-bottom: 3px; font-weight: bold; color: var(--accent); }
  
  #choices { 
      padding: 5px; 
      border-radius: 4px; 
      max-height: 200px; 
      min-height: 40px; 
      overflow-y: auto; 
      background: rgba(255, 255, 255, 0.03); 
      box-sizing: border-box; 
      margin-top: 5px;
  }
  .choice{ margin-bottom:10px; padding: 8px; width:100%; border: 1px solid var(--border-dark); border-radius: 4px; background: var(--input-bg); box-sizing: border-box; }
  .choice:last-child { margin-bottom: 0; }
  .choice-text-group, .choice-result-group, .choice-trigger-group, .choice-item-group, .choice-hp-group { padding: 2px 0; } 
  .choice label { font-weight: 400; font-size: 13px; color: var(--text-color); margin-top: 5px; margin-bottom: 3px; }
  
  .choice-text-group {display: flex;gap: 5px;width: 100%;align-items: center;}
  .choice-text-group input.choiceText {flex: 1;padding: 6px;line-height: normal; min-width: 0;}
  .choice-text-group button {padding: 6px 10px;font-size: 13px;flex-shrink: 0;width: 30px;height: auto;}
  
  .choice-result-group { display: flex;flex-direction: column;gap: 5px;padding-left: 0;width: 100%;box-sizing: border-box; }
  .choice-result-group textarea.choiceResultText {flex: 1;resize: vertical;min-height: 50px;max-height: 150px;padding: 6px; margin-bottom: 0;}
  
  .choice-trigger-group, .choice-item-group { display: flex; gap: 8px; margin-bottom: 0; align-items: center; padding-left: 0; width: 100%; box-sizing: border-box; }
  .choice-hp-group { display: flex; gap: 8px; margin-bottom: 0; align-items: center; padding-left: 0; width: 100%; box-sizing: border-box; } 
  
  .choice-trigger-group label, .choice-item-group label, .choice-hp-group label { flex-shrink: 0; width: 70px; } 
  .choice-trigger-group select.choiceTrigger { flex: 0 0 120px; width: 120px; padding: 6px; }
  .choice-trigger-group input.choiceData { flex: 1; padding: 6px; min-width: 50px; }
  
  .choice-item-group select, .choice-item-group input {padding: 6px; flex-shrink: 0; }
  .choice-item-group select { width: 150px; }
  .choice-item-group input[type="number"] { width: 80px; text-align: center;} 
  .choice-hp-group input.choiceHpChange { flex: 0 0 80px; width: 80px; text-align: center; padding: 6px; } 

  #addChoiceContainer { text-align: right; margin-top: 10px; margin-bottom: 5px; }
  .modal > div:last-child { margin-top: 10px !important; }
  #encounterModal {min-width: 500px;padding: 20px;}
  #encounterModal h4 {color: #fff;border-color: var(--accent);}
  #encounterModal .info-text { white-space: pre-wrap;background: rgba(255,255,255,0.05);padding: 10px;border-radius: 5px;margin-bottom: 15px;border: 1px solid var(--border-dark);font-style: italic; }
  #encounterChoices button {display: block;width: 100%;margin-top: 10px;background: #444;}
  #encounterChoices button:hover {background: var(--accent);}
  /* **[수정]** 선택지 비활성화 스타일 */
  #encounterChoices button:disabled { 
      background: #333 !important; 
      color: #999; 
      opacity: 0.7; 
      cursor: default;
  }
  .char-img-container { display: flex;justify-content: center;margin-bottom: 15px;height: 250px;width: 100%;overflow: hidden; }
  .char-img-container img { max-width: 100%; height: 100%; width: 100%; object-fit: cover; border-radius: 5px; box-shadow: 0 0 10px rgba(192, 57, 43, 0.5); }

  /* Item Use Modal **[수정]** 버튼 하단 정렬 */
  #itemUseModal .modal { 
      min-width: 350px; 
      display: flex; 
      flex-direction: column; 
  }
  #itemUseModal h4 { border-bottom: none; }
  #itemUseModal .item-image { width: 80px; height: 80px; margin: 10px auto; display: block; }
  #itemUseModal .item-desc { 
      text-align: center; 
      margin-bottom: 10px; 
      flex-grow: 1; 
  }
  #itemUseModal .modal > div:last-child {
      padding-top: 10px; 
      border-top: 1px solid var(--border-dark); 
      margin-top: 0;
      display: flex; /* **[추가]** */
      justify-content: flex-end; /* **[추가]** */
      gap: 10px;
  }

  /* Inventory Modal */
  #inventoryModal .modal { min-width: 300px; max-height: 80vh; overflow-y: auto; }
  .inventory-admin-item { 
      display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px dashed var(--border-dark);
  }
  .inventory-admin-item:last-child { border-bottom: none; }
  .inventory-admin-item button { 
      background: #550000; border-color: #770000; padding: 4px 8px; font-size: 11px;
      transition: opacity 0.2s;
  }
</style>
</head>
<body>
<audio id="bgmAudio" loop preload="auto"></audio>
<div id="topBar">
    <div id="bgmControls"> 
        <input type="range" id="bgmVolume" min="0" max="1" step="0.05" value="0.5" title="볼륨">
        <button id="bgmToggleBtn">PLAY</button> 
    </div>
    <div id="topBarControls">
        <button id="playerLoginBtnTop">플레이어 로그인</button>
        <button id="adminBtn">관리자</button>
    </div>
</div>

<div id="logChatPanel" class="side-panel">
    <div class="chat-controls">
        <button id="logToggleBtn" title="전체 채팅 기록 보기">
            🔗
        </button>
        <button id="deleteAllChatBtn" title="채팅 전체삭제" style="background: #880000; border-color: #aa0000; display: none;">
            🗑️
        </button> 
        <div style="display: flex; align-items: center; flex-grow: 1;">
            <input type="text" id="chatNickname" placeholder="닉네임" value="탐험가">
        </div>
    </div>
    <div id="logDisplay">
        <div class="log-item system">시스템: 로그/채팅 시작.</div>
    </div>
    <div class="chat-input-group">
        <input type="text" id="chatInput" placeholder="채팅 입력" disabled>
        <button id="sendChatBtn" disabled>전송</button>
    </div>
</div>

<div id="container">
  <canvas id="game" width="640" height="480"></canvas>
  <div id="grid"></div>
  <div id="dragGhost"></div> 
</div>

<div id="statusInventoryPanel" class="side-panel">
    <div id="playerContent" style="display:none;"> 
        <h4>플레이어 상태</h4>
        <div id="playerStatus">
            HP: <span id="playerHP">100</span>
        </div>
        <h4>인벤토리</h4>
        <div id="inventoryList">
        </div>
    </div>
    <div id="adminRightInfo" style="display:none; padding: 5px;">
        <h4>관리자 정보</h4>
        <p><strong>현재 맵:</strong> <span id="adminInfoMap">-</span></p>
        <p><strong>남은 조우 수:</strong> <span id="adminInfoRemainingEnc">0</span></p>
        <hr>
        <p style="margin-bottom: 5px;"><strong>현재 맵 플레이어:</strong></p>
        <div id="playerOnMapList">
             <div style="text-align: center; color: #aaa; font-size: 13px;">플레이어 없음</div>
        </div>
    </div>
</div>

<div id="adminPanel">
  <h4>
    <span>관리자 패널</span>
    <button id="minimizeBtn" title="최소화/복원">[—]</button>
  </h4>
  
  <div class="admin-tabs">
    <button id="mapTabBtn" class="active">맵 설정</button>
    <button id="userTabBtn">사용자 관리</button>
    <button id="itemTabBtn">아이템 관리</button>
  </div>
  
  <div id="mapTabContent" class="admin-tab-content active">
    <div class="row"><label>맵 이름</label><input id="mapName" type="text"><button id="saveMap">맵 저장</button></div>
    <div class="row"><label>맵 이미지</label><input id="mapUrl" type="text" placeholder="이미지 URL"></div>
    <div class="row"><label>BGM URL</label><input id="bgmUrl" type="text" placeholder="배경음악 URL"></div> 
    <div class="row">
        <label>시작 좌표</label>
        <input id="startX" type="number" min="0" style="width: 50px; flex-grow: 0; text-align: center;" placeholder="X">
        <input id="startY" type="number" min="0" style="width: 50px; flex-grow: 0; text-align: center;" placeholder="Y">
        <button id="setPlayerPos" style="flex-shrink: 0;">설정</button>
    </div>
    
    <div class="row">
        <label>맵 이동 좌표</label>
        <input id="transitionX" type="number" min="0" style="width: 50px; flex-grow: 0; text-align: center;" placeholder="X">
        <input id="transitionY" type="number" min="0" style="width: 50px; flex-grow: 0; text-align: center;" placeholder="Y">
        <button id="setTransitionPos" style="flex-shrink: 0;">설정</button>
    </div>
    <div class="row"><label>이동할 맵</label><input id="nextMapName" type="text" placeholder="클리어 시 이동할 맵 이름"></div>

    <div class="control-group"> 
      <button id="reload">로드</button>
      <button id="toggleGrid">그리드</button>
      <button id="toggleEncounter">조우 추가</button> 
      <button id="toggleImpassable">제한 추가</button> 
    </div>
    
    <hr>
    
    <p style="text-align: center; color: #999; font-size: 13px;">맵 상의 조우 및 이동 제한 구역을 **클릭**하여 수정/삭제합니다.</p>
    
    <div id="mapButtons" style="margin-top:10px;">
        <div class="row"> 
            <button id="initMapBtn" style="background: #e74c3c; border-color: #c0392b;">현재 맵 초기화 (삭제 X)</button>
        </div>
    </div>

    <hr>
    <h5>저장된 맵 목록 (클릭 로드)</h5>
    <div class="list-container" id="mapListContainer">
        </div>
  </div>
  
  <div id="userTabContent" class="admin-tab-content">
    <h5>플레이어 계정 관리</h5>
    <div class="row">
      <input type="text" id="newUserId" placeholder="새 플레이어 ID">
      <input type="text" id="newUserCharUrl" placeholder="캐릭터 이미지 URL">
      <button id="addPlayerBtn">생성</button>
    </div>
    <div class="list-container" id="userList"></div>
    
    <h5 style="margin-top: 15px;">플레이어 상태 관리</h5>
    <div class="row">
        <select id="selectPlayerId" style="flex-grow: 1;"></select>
        <input type="number" id="playerHpInput" placeholder="HP" style="width: 50px;">
        <button id="updatePlayerStatusBtn">상태 저장</button>
    </div>

    <h5 style="margin-top: 15px;">플레이어 맵/위치 관리</h5>
    <div class="row">
        <select id="selectPlayerIdMap" style="flex-grow: 1;"></select>
        <input type="text" id="playerMapInput" placeholder="맵 이름">
        <input type="number" id="playerXInput" placeholder="X" min="0" style="width: 50px;">
        <input type="number" id="playerYInput" placeholder="Y" min="0" style="width: 50px;">
        <button id="updatePlayerMapBtn">위치 저장</button>
    </div>

    <h5 style="margin-top: 15px;">아이템 직접 지급</h5>
    <div class="row">
        <select id="giveItemPlayerSelect" style="flex-grow: 1;"></select>
        <select id="giveItemSelect" style="width: 120px;"></select> <button id="giveItemBtn">지급</button>
    </div>
  </div>

  <div id="itemTabContent" class="admin-tab-content">
    <h5>아이템 정의 관리</h5>
    <div class="row">
      <input type="text" id="newItemId" placeholder="아이템 ID (고유)">
      <input type="text" id="newItemName" placeholder="아이템 이름">
    </div>
    <div class="row">
        <input type="text" id="newItemImageUrl" placeholder="이미지 URL">
        <input type="number" id="newItemHpRecover" placeholder="HP 회복량 (0이면 사용 불가)" min="0" value="0" style="width: 80px;"> <button id="addItemBtn" style="flex-shrink: 0;">등록</button>
    </div>
    <textarea id="newItemDescription" placeholder="아이템 설명" rows="2"></textarea>
    <div class="list-container" id="itemList"></div> </div>
</div>

<div class="modal-bg" id="loginBox">
  <div class="modal">
    <div>관리자 로그인</div>
    <input type="password" id="adminPw" placeholder="비밀번호 입력">
    <button id="loginBtn">로그인</button>
  </div>
</div>

<div class="modal-bg" id="playerLoginBox">
    <div class="modal">
      <div>플레이어 로그인</div>
      <input type="text" id="playerIdInput" placeholder="아이디 입력">
      <button id="playerLoginBtnSubmit">로그인</button>
    </div>
</div>

<div class="modal-bg" id="editModal">
  <div class="modal">
    <h4>조우 수정</h4>
    <label>이름</label><input id="encName" type="text">
    <label>지문</label><textarea id="encText" placeholder="조우 시 플레이어에게 보일 지문" rows="3"></textarea>
    
    <label>획득 아이템 ID (선택)</label>
    <select id="encItemIdSelect" style="margin-bottom: 5px;"></select>
    <input id="encItemIdManual" type="text" placeholder="직접 입력 또는 새로운 아이템 ID" style="display:none;">
    <input type="checkbox" id="encItemIdManualCheck"><label for="encItemIdManualCheck" style="display: inline-block; font-weight: normal; margin-left: 5px; color: #aaa;">직접 입력/없는 아이템</label>

    <label>캐릭터 이미지 URL</label><input id="encCharUrl" type="text" placeholder="조우 시 띄울 이미지 URL">
    
    <label id="choicesLabel">선택지</label> <div id="choices"></div>
    <div id="addChoiceContainer" style="text-align: right;"><button id="addChoice">선택지 추가</button></div>
    
    <label>기본 트리거 (선택지가 없을 때만 사용)</label>
    <select id="encTrigger">
        <option value="none">없음</option>
        <option value="sound">사운드</option>
        <option value="image">이미지 팝업</option>
        <option value="map">맵 전환</option>
    </select>
    
    <label>기본 트리거 데이터(URL/맵명)</label><input id="encData" type="text">
    
    <div style="margin-top:20px; text-align:right; display: flex; justify-content: space-between; align-items: center;"> 
        <button id="deleteEncEdit" style="background: #e74c3c; border-color: #c0392b; font-size: 18px; line-height: 1; padding: 6px 10px;">
            🗑️
        </button>
        <div>
            <button id="saveEncEdit">저장</button>
            <button id="closeEncEdit">닫기</button>
        </div>
    </div>
  </div>
</div>

<div class="modal-bg" id="encounterModalBg">
    <div class="modal" id="encounterModal">
        <div class="char-img-container" id="encCharImgContainer">
            <img id="encCharImg" alt="Encounter Character" style="display:none;"/>
        </div>
        <h4 id="encModalName"></h4>
        <div class="info-text" id="encModalText"></div>
        <div id="encounterChoices"></div> <div style="margin-top:20px;text-align:right"><button id="closeEncounterModal">계속 진행</button></div>
    </div>
</div>

<div class="modal-bg" id="itemUseModalBg">
    <div class="modal" id="itemUseModal">
        <h4 id="itemUseName"></h4>
        <img id="itemUseImage" class="item-image" alt="Item Image"/>
        <div class="item-desc" id="itemUseDescription"></div>
        <div>
            <button id="useItemBtn" style="background: #2ecc71;">사용</button>
            <button id="closeItemUseModal">닫기</button>
        </div>
    </div>
</div>

<div class="modal-bg" id="inventoryModal">
    <div class="modal">
        <h4 id="inventoryModalTitle">플레이어 인벤토리</h4>
        <div class="list-container" id="inventoryModalList"> 
        </div>
        <div style="margin-top:10px;text-align:right">
            <button id="closeInventoryModal">닫기</button>
        </div>
    </div>
</div>

<script type="module">
/* Firebase + 앱 로직 통합 */
// NOTE: Please replace with your actual Firebase configuration
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, deleteDoc, collection, query, getDocs, onSnapshot, updateDoc, arrayUnion, arrayRemove, where, orderBy, limit, addDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-storage.js";

const firebaseConfig = {
    apiKey: "AIzaSyCtPPF9Y93XVKHjo5_mmmxycf0CUJjWIRo", // <-- [필수 수정] 실제 키로 변경하세요
    authDomain: "horror-game-14aa8.firebaseapp.com",
    projectId: "horror-game-14aa8",
    storageBucket: "horror-game-14aa8.firebasestorage.app",
    messagingSenderId: "125297141331",
    appId: "1:125299141331:web:a15f971c34dde0c7d708a6"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

const ADMIN_EMAIL = "test@gmail.com"; // <-- [필수 수정] 실제 관리자 이메일로 변경하세요
const ADMIN_DUMMY_PW = "testpassword"; // <-- [필수 수정] 실제 관리자 비밀번호로 변경하세요
const GRID = 32;
const MAX_HP = 100;

/* --- State Variables --- */
// **[수정]** encountered 필드 수정: { x_y: { usedChoices: ["choiceId1", ...], visited: true } }
let player = { 
    x: 0, 
    y: 0, 
    hp: MAX_HP, 
    charUrl: '', 
    inventory: {}, 
    encountered: {} // Key: "mapname_x_y", Value: { usedChoices: ["choiceId"], visited: true }
}; 
let currentMapName = 'default';
let encounterPoints = []; // [{x, y, data: {...}}]
let impassablePoints = []; // [{x, y}]
let mapData = { url: '', spriteUrl: '', bgmUrl: '', startX: 0, startY: 0, transitionX: null, transitionY: null, nextMapName: '' };
let isGridMode = false;
let isEncounterMode = false;
let isImpassableMode = false;
let dragStartPoint = null;
let currentEdit = null; // Currently selected encounter point for editing
let itemDefinitions = {}; // {itemId: {name, imageUrl, hpRecover, description}}
let loggedInUserId = null;
let playerMode = false;
let currentSelectedItem = null; // Item ID for itemUseModal
let adminMode = false;
let chatUnsub = null;
let usersData = {}; // {userId: {hp, currentMap, x, y, charUrl, inventory, encountered}} 
let characterImage = new Image();
let mapImage = new Image();
let mapLoaded = false;
let isMoving = false;
let isEncountering = false;
let animationFrameId = null;

/* --- UI Bindings (Explicitly defined to fix ReferenceError) --- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const logDisplay = document.getElementById('logDisplay');
const bgmAudio = document.getElementById('bgmAudio');
const bgmToggleBtn = document.getElementById('bgmToggleBtn');
const bgmVolume = document.getElementById('bgmVolume');
const playerHPDisplay = document.getElementById('playerHP');

// Main Game/Admin
const container = document.getElementById('container');
const adminPanel = document.getElementById('adminPanel');
const mapNameInput = document.getElementById('mapName');
const mapUrlInput = document.getElementById('mapUrl');
const bgmUrlInput = document.getElementById('bgmUrl');
const startXInput = document.getElementById('startX');
const startYInput = document.getElementById('startY');
const transitionXInput = document.getElementById('transitionX');
const transitionYInput = document.getElementById('transitionY');
const nextMapNameInput = document.getElementById('nextMapName');
const adminBtn = document.getElementById('adminBtn');
// **[수정]** 맵 초기화 버튼 ID 변경 및 바인딩
const initMapBtn = document.getElementById('initMapBtn'); 

// Admin Modals (Encounter Edit)
const editModal = document.getElementById('editModal');
const encNameInput = document.getElementById('encName');
const encTextInput = document.getElementById('encText');
const encCharUrlInput = document.getElementById('encCharUrl');
const encTriggerSelect = document.getElementById('encTrigger');
const encDataInput = document.getElementById('encData');
const encItemIdSelect = document.getElementById('encItemIdSelect');
const encItemIdManual = document.getElementById('encItemIdManual');
const encItemIdManualCheck = document.getElementById('encItemIdManualCheck');
const choicesDiv = document.getElementById('choices');

// Player Modals (Encounter/Item)
const encounterModalBg = document.getElementById('encounterModalBg');
const encModalName = document.getElementById('encModalName');
const encModalText = document.getElementById('encModalText');
const encounterChoicesDiv = document.getElementById('encounterChoices');
const closeEncounterModalBtn = document.getElementById('closeEncounterModal');
const itemUseModalBg = document.getElementById('itemUseModalBg');
const useItemBtn = document.getElementById('useItemBtn');
const closeItemUseModalBtn = document.getElementById('closeItemUseModal');

// Item/User Tab elements
const itemListDiv = document.getElementById('itemList'); // **[추가]** 아이템 목록 컨테이너
const giveItemSelect = document.getElementById('giveItemSelect'); // **[추가]** 아이템 지급 드롭다운


/* --- Utility Functions --- */

const addLogItem = (text, type = 'log', isChat = false) => {
    const item = document.createElement('div');
    item.className = isChat ? `chat-item ${type}` : `log-item ${type}`;
    item.innerHTML = text;
    logDisplay.appendChild(item);
    logDisplay.scrollTop = logDisplay.scrollHeight;
};

const showModal = (modalElement) => {
    modalElement.style.display = 'flex';
};

const hideModal = (modalElement) => {
    modalElement.style.display = 'none';
};

const generateUniqueId = () => {
    return '_' + Math.random().toString(36).substr(2, 9);
};

/* --- Game Engine Logic --- */

const drawMap = () => {
    // ... (map drawing logic)
    if (!mapLoaded || !mapImage.complete) {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.fillText('맵 로딩 중...', canvas.width / 2, canvas.height / 2);
        return;
    }
    ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

    if (isGridMode) {
        drawGrid();
    }
    drawImpassablePoints();
    drawEncounterPoints();
    drawStartPoint();
    drawTransitionPoint();
};

const drawImpassablePoints = () => {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    impassablePoints.forEach(p => {
        ctx.fillRect(p.x * GRID, p.y * GRID, GRID, GRID);
    });
};

const drawEncounterPoints = () => {
    ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
    encounterPoints.forEach(p => {
        ctx.fillRect(p.x * GRID, p.y * GRID, GRID, GRID);
    });
};

const drawStartPoint = () => {
    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
    ctx.fillRect(mapData.startX * GRID, mapData.startY * GRID, GRID, GRID);
    ctx.strokeStyle = 'lime';
    ctx.lineWidth = 2;
    ctx.strokeRect(mapData.startX * GRID + 2, mapData.startY * GRID + 2, GRID - 4, GRID - 4);
};

const drawTransitionPoint = () => {
    if (mapData.transitionX !== null && mapData.transitionY !== null) {
        ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
        ctx.fillRect(mapData.transitionX * GRID, mapData.transitionY * GRID, GRID, GRID);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.strokeRect(mapData.transitionX * GRID + 2, mapData.transitionY * GRID + 2, GRID - 4, GRID - 4);
    }
};

const drawGrid = () => {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    for (let x = 0; x < canvas.width / GRID; x++) {
        ctx.beginPath();
        ctx.moveTo(x * GRID, 0);
        ctx.lineTo(x * GRID, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y < canvas.height / GRID; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * GRID);
        ctx.lineTo(canvas.width, y * GRID);
        ctx.stroke();
    }
};

const drawPlayer = () => {
    if (!loggedInUserId || !playerMode) return;
    
    // Fallback if character image is not loaded
    if (!characterImage.complete || !player.charUrl) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(player.x * GRID, player.y * GRID, GRID, GRID);
        return;
    }

    ctx.drawImage(characterImage, player.x * GRID, player.y * GRID, GRID, GRID);
};

const draw = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawPlayer();
    animationFrameId = requestAnimationFrame(draw);
};

/* --- Firebase Interaction: Player State --- */

const savePlayerState = async () => {
    if (!loggedInUserId) return;
    try {
        const playerRef = doc(db, 'players', loggedInUserId);
        await setDoc(playerRef, {
            id: loggedInUserId,
            hp: player.hp,
            currentMap: currentMapName,
            x: player.x,
            y: player.y,
            charUrl: player.charUrl,
            inventory: player.inventory,
            encountered: player.encountered // **[수정]** encountered 필드 저장
        }, { merge: true });
        // updatePlayerOnMapList(); // Keep the admin right panel updated
    } catch (e) {
        console.error("Error saving player state: ", e);
    }
};

const loadPlayerState = async (playerId) => {
    const playerRef = doc(db, 'players', playerId);
    const docSnap = await getDoc(playerRef);

    if (docSnap.exists()) {
        const data = docSnap.data();
        player.x = data.x || mapData.startX || 0;
        player.y = data.y || mapData.startY || 0;
        player.hp = data.hp || MAX_HP;
        player.charUrl = data.charUrl || '';
        player.inventory = data.inventory || {};
        player.encountered = data.encountered || {}; // **[수정]** encountered 필드 로드

        // Load character image
        if (player.charUrl && player.charUrl !== characterImage.src) {
            characterImage.onload = () => {
                draw(); // Redraw once image is loaded
            };
            characterImage.src = player.charUrl;
        }

        // Check if the map has changed
        if (data.currentMap && data.currentMap !== currentMapName) {
            await loadMapDataFromFirestore(data.currentMap);
        }
        
        updatePlayerUI(true);
        addLogItem(`시스템: 플레이어 [${playerId}] 상태 로드 완료. 현재 맵: ${currentMapName}`, 'system');

        // Check if player is on a map different from the one they logged into.
        if (data.currentMap && data.currentMap !== currentMapName) {
            await loadMapDataFromFirestore(data.currentMap);
        }

    } else {
        // New player: Initialize state
        player.x = mapData.startX || 0;
        player.y = mapData.startY || 0;
        player.hp = MAX_HP;
        player.inventory = {};
        player.encountered = {}; // **[수정]** 초기화
        
        // Find the user's initial charUrl from usersData if available
        const userData = usersData[playerId];
        player.charUrl = userData ? userData.charUrl : ''; 
        if (player.charUrl && player.charUrl !== characterImage.src) {
             characterImage.src = player.charUrl;
        }

        // Save initial state
        await savePlayerState();
        addLogItem(`시스템: 새로운 플레이어 [${playerId}] 상태 초기화 및 저장.`, 'system');
    }
};

/* --- Firebase Interaction: Map Data --- */

const loadMapDataFromFirestore = async (mapId) => {
    const mapRef = doc(db, 'maps', mapId);
    const docSnap = await getDoc(mapRef);

    if (docSnap.exists()) {
        const data = docSnap.data();
        currentMapName = mapId;
        mapData = {
            url: data.url || '',
            bgmUrl: data.bgmUrl || '',
            startX: data.startX || 0,
            startY: data.startY || 0,
            transitionX: data.transitionX === undefined ? null : data.transitionX,
            transitionY: data.transitionY === undefined ? null : data.transitionY,
            nextMapName: data.nextMapName || ''
        };
        encounterPoints = data.encounterPoints || [];
        impassablePoints = data.impassablePoints || [];

        // Update Admin UI
        mapNameInput.value = currentMapName;
        mapUrlInput.value = mapData.url;
        bgmUrlInput.value = mapData.bgmUrl;
        startXInput.value = mapData.startX;
        startYInput.value = mapData.startY;
        transitionXInput.value = mapData.transitionX === null ? '' : mapData.transitionX;
        transitionYInput.value = mapData.transitionY === null ? '' : mapData.transitionY;
        nextMapNameInput.value = mapData.nextMapName;
        document.getElementById('adminInfoMap').textContent = currentMapName;
        document.getElementById('adminInfoRemainingEnc').textContent = encounterPoints.length;

        // Load map image
        mapLoaded = false;
        mapImage.onload = () => {
            mapLoaded = true;
            draw();
        };
        mapImage.onerror = () => {
            mapLoaded = true;
            addLogItem(`시스템: 맵 이미지 로드 실패. 빈 화면으로 대체.`, 'system');
            draw();
        };
        mapImage.src = mapData.url || '';

        // Play BGM
        if (mapData.bgmUrl) {
            bgmAudio.src = mapData.bgmUrl;
            bgmAudio.play().catch(e => console.log("BGM Play failed (user interaction required):", e));
            bgmToggleBtn.textContent = 'PAUSE';
        } else {
            bgmAudio.pause();
            bgmToggleBtn.textContent = 'PLAY';
            bgmAudio.src = '';
        }

        addLogItem(`시스템: 맵 **${currentMapName}** 로드 완료.`, 'system');

        return true;
    } else {
        addLogItem(`시스템: 맵 **${mapId}** 데이터 없음. 초기 상태로 로드.`, 'system');
        
        // Save an empty map document to Firestore so it appears in the list
        await setDoc(mapRef, {
            url: '',
            bgmUrl: '',
            startX: 0,
            startY: 0,
            transitionX: null,
            transitionY: null,
            nextMapName: '',
            encounterPoints: [],
            impassablePoints: []
        });

        // Local state reset for empty map
        currentMapName = mapId;
        mapData = { url: '', bgmUrl: '', startX: 0, startY: 0, transitionX: null, transitionY: null, nextMapName: '' };
        encounterPoints = [];
        impassablePoints = [];
        mapNameInput.value = currentMapName; 
        mapUrlInput.value = '';
        bgmUrlInput.value = '';
        startXInput.value = 0;
        startYInput.value = 0;
        transitionXInput.value = '';
        transitionYInput.value = '';
        nextMapNameInput.value = '';
        document.getElementById('adminInfoMap').textContent = currentMapName;
        document.getElementById('adminInfoRemainingEnc').textContent = 0;

        mapLoaded = true;
        mapImage.src = '';
        bgmAudio.pause();
        bgmToggleBtn.textContent = 'PLAY';
        bgmAudio.src = '';

        return false;
    }
};

const saveMapData = async () => {
    const mapId = mapNameInput.value.trim();
    if (!mapId) {
        alert('맵 이름을 입력해주세요.');
        return;
    }

    const mapRef = doc(db, 'maps', mapId);

    mapData.url = mapUrlInput.value;
    mapData.bgmUrl = bgmUrlInput.value;
    mapData.startX = parseInt(startXInput.value) || 0;
    mapData.startY = parseInt(startYInput.value) || 0;
    mapData.transitionX = transitionXInput.value ? parseInt(transitionXInput.value) : null;
    mapData.transitionY = transitionYInput.value ? parseInt(transitionYInput.value) : null;
    mapData.nextMapName = nextMapNameInput.value;

    try {
        await setDoc(mapRef, {
            ...mapData,
            encounterPoints: encounterPoints,
            impassablePoints: impassablePoints
        }, { merge: false });

        currentMapName = mapId; // Ensure currentMapName is updated if a new map was created/saved
        await loadMapDataFromFirestore(currentMapName); // Reload to apply changes immediately
        await reloadMapList(); // Update the map list
        addLogItem(`시스템: 맵 **${mapId}** 저장 완료.`, 'system');

        // Update all players on the old map (if mapId changed)
        if (mapId !== currentMapName) {
             // This case is unlikely if we always set currentMapName = mapId above, but included for robustness.
        }

    } catch (e) {
        console.error("Error saving map data: ", e);
        addLogItem(`시스템: 맵 저장 실패.`, 'system');
    }
};

// **[수정]** 맵 삭제 기능 제거, 맵 초기화 기능으로 변경
const initCurrentMap = async () => {
    if (!currentMapName || currentMapName === 'default') {
         alert('기본 맵은 초기화할 수 없습니다.');
         return;
    }
    
    if (confirm(`**${currentMapName}** 맵의 모든 조우, 제한 구역, 시작 좌표, 이동 좌표, BGM URL, 맵 이미지 URL을 초기화하시겠습니까? (맵 자체의 Firestore 문서는 삭제되지 않습니다.)`)) {
        addLogItem(`시스템: **${currentMapName}** 맵 초기화 시작. (Firestore 문서 유지)`, 'system');

        const mapRef = doc(db, 'maps', currentMapName);

        // Map data to reset to minimal state
        const resetMapData = {
            url: '',
            bgmUrl: '',
            startX: 0,
            startY: 0,
            transitionX: null,
            transitionY: null,
            nextMapName: '',
            encounterPoints: [],
            impassablePoints: []
        };
        
        try {
            // Update the map document to reset all fields
            await setDoc(mapRef, resetMapData);

            // Local state reset
            mapData = resetMapData;
            encounterPoints = [];
            impassablePoints = [];
            
            // Update UI
            mapUrlInput.value = '';
            bgmUrlInput.value = '';
            startXInput.value = 0;
            startYInput.value = 0;
            transitionXInput.value = '';
            transitionYInput.value = '';
            nextMapNameInput.value = '';
            document.getElementById('adminInfoRemainingEnc').textContent = 0;
            
            // Reload map image/bgm
            mapImage.src = '';
            mapLoaded = true;
            bgmAudio.pause();
            bgmToggleBtn.textContent = 'PLAY';
            bgmAudio.src = '';

            addLogItem(`시스템: **${currentMapName}** 맵 초기화 완료.`, 'system');
            draw();
            
            // Note: Player position reset to (0,0) will happen on next login/map load if mapData.startX/Y are 0.
            // For the admin's immediate view, the player is moved to (0,0) only if mapData.startX/Y are used on load.
            // We'll update the player's position to the new start point (0,0) if they are on this map.
            if (loggedInUserId && playerMode && currentMapName === player.currentMap) {
                 player.x = 0;
                 player.y = 0;
                 await savePlayerState();
            }

        } catch (e) {
            console.error("Error initializing map: ", e);
            addLogItem(`시스템: 맵 초기화 실패.`, 'system');
        }
    }
};

const deleteMap = async (mapId) => {
    if (mapId === 'default') {
        alert('기본 맵은 삭제할 수 없습니다.');
        return;
    }
    if (confirm(`맵 **${mapId}**를 Firestore에서 영구적으로 삭제하시겠습니까?`)) {
        try {
            await deleteDoc(doc(db, 'maps', mapId));
            addLogItem(`시스템: 맵 **${mapId}** 삭제 완료.`, 'system');
            await reloadMapList();
            if (mapId === currentMapName) {
                // If current map is deleted, load 'default'
                await loadMapDataFromFirestore('default');
            }
        } catch (e) {
            console.error("Error deleting map: ", e);
            addLogItem(`시스템: 맵 삭제 실패.`, 'system');
        }
    }
};

const reloadMapList = async () => {
    const mapListContainer = document.getElementById('mapListContainer');
    mapListContainer.innerHTML = '';
    
    try {
        const q = query(collection(db, 'maps'), orderBy('__name__'));
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            mapListContainer.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">저장된 맵이 없습니다.</div>';
            return;
        }

        querySnapshot.forEach((doc) => {
            const mapId = doc.id;
            const item = document.createElement('div');
            item.className = 'map-list-item';
            item.innerHTML = `
                <span title="클릭하여 로드">${mapId}</span>
                <div>
                    <button onclick="deleteMap('${mapId}')" style="background: #e74c3c; border-color: #c0392b;">삭제</button>
                </div>
            `;
            item.querySelector('span').addEventListener('click', () => loadMapDataFromFirestore(mapId));
            mapListContainer.appendChild(item);
        });
    } catch (e) {
        console.error("Error reloading map list: ", e);
        mapListContainer.innerHTML = '<div style="text-align: center; color: #ff0000; font-size: 13px;">맵 목록 로드 오류.</div>';
    }
};

/* --- Encounter Logic --- */

const getEncounterAt = (x, y) => {
    return encounterPoints.find(p => p.x === x && p.y === y);
};

const getImpassableAt = (x, y) => {
    return impassablePoints.find(p => p.x === x && p.y === y);
};

const addEncounter = (x, y, data = {}) => {
    const existing = getEncounterAt(x, y);
    if (existing) {
        alert('이미 조우 지점이 있습니다. 수정 모드로 전환합니다.');
        openEditModal(existing);
        return;
    }
    
    // Create a new encounter object with a unique choice ID structure
    const newEncData = {
        name: '새로운 조우',
        text: '조우 지문',
        charUrl: '',
        itemId: '',
        trigger: 'none',
        data: '',
        choices: [
            { id: generateUniqueId(), text: '선택지 1', resultText: '선택지 1 결과 지문', trigger: 'none', data: '', hpChange: 0, itemId: '' },
            { id: generateUniqueId(), text: '선택지 2', resultText: '선택지 2 결과 지문', trigger: 'none', data: '', hpChange: 0, itemId: '' }
        ],
        ...data 
    };

    const newEnc = { x, y, data: newEncData };
    encounterPoints.push(newEnc);
    document.getElementById('adminInfoRemainingEnc').textContent = encounterPoints.length;
    openEditModal(newEnc); 
    draw();
};

const openEditModal = (enc) => {
    currentEdit = enc;
    encNameInput.value = enc.data.name;
    encTextInput.value = enc.data.text;
    encCharUrlInput.value = enc.data.charUrl;
    encTriggerSelect.value = enc.data.trigger || 'none';
    encDataInput.value = enc.data.data || '';

    // Handle item selection
    const itemId = enc.data.itemId || '';
    encItemIdSelect.value = itemId;
    encItemIdManual.value = itemId;
    const isManual = !encItemIdSelect.querySelector(`option[value="${itemId}"]`);
    encItemIdManualCheck.checked = isManual;
    encItemIdManual.style.display = isManual ? 'block' : 'none';
    if (!isManual) encItemIdManual.value = '';

    renderChoices(enc.data.choices);
    showModal(editModal);
};

const renderChoices = (choices) => {
    choicesDiv.innerHTML = '';
    choices.forEach((choice, index) => {
        const choiceElement = createChoiceElement(choice, index);
        choicesDiv.appendChild(choiceElement);
    });
};

const createChoiceElement = (choice, index) => {
    const div = document.createElement('div');
    div.className = 'choice';
    div.dataset.index = index;
    div.innerHTML = `
        <input type="hidden" class="choiceId" value="${choice.id || generateUniqueId()}">
        <div class="choice-text-group">
            <label>선택지 텍스트</label>
            <input type="text" class="choiceText" value="${choice.text || ''}">
            <button class="delChoiceBtn" style="background: #e74c3c; border-color: #c0392b;">X</button>
        </div>
        <div class="choice-result-group">
            <label>결과 지문</label>
            <textarea class="choiceResultText">${choice.resultText || ''}</textarea>
        </div>
        <div class="choice-hp-group">
            <label>HP 변화</label>
            <input type="number" class="choiceHpChange" value="${choice.hpChange || 0}">
        </div>
        <div class="choice-item-group">
            <label>아이템</label>
            <select class="choiceItemIdSelect" style="flex-grow: 1;"></select>
            <input type="number" class="choiceItemQuantity" value="1" min="1" style="width: 50px;">
        </div>
        <div class="choice-trigger-group">
            <label>트리거</label>
            <select class="choiceTrigger" style="flex-shrink: 0;">
                <option value="none">없음</option>
                <option value="sound">사운드</option>
                <option value="image">이미지 팝업</option>
                <option value="map">맵 전환</option>
            </select>
            <input type="text" class="choiceData" placeholder="URL/맵명" value="${choice.data || ''}">
        </div>
    `;

    // Populate item dropdown for choice
    const itemSelect = div.querySelector('.choiceItemIdSelect');
    itemSelect.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = '아이템 없음';
    itemSelect.appendChild(defaultOption);
    
    for (const itemId in itemDefinitions) {
        const item = itemDefinitions[itemId];
        const option = document.createElement('option');
        option.value = itemId;
        option.textContent = `${item.name} (${itemId})`;
        itemSelect.appendChild(option);
    }
    
    // Set values from current choice data
    itemSelect.value = choice.itemId || '';
    div.querySelector('.choiceItemQuantity').value = choice.itemQuantity || 1;
    div.querySelector('.choiceTrigger').value = choice.trigger || 'none';

    div.querySelector('.delChoiceBtn').addEventListener('click', () => deleteChoice(index));
    
    return div;
};

const addChoice = () => {
    if (!currentEdit) return;
    const newChoice = { 
        id: generateUniqueId(), 
        text: '새로운 선택지', 
        resultText: '선택 결과 지문', 
        trigger: 'none', 
        data: '', 
        hpChange: 0,
        itemId: '',
        itemQuantity: 1
    };
    currentEdit.data.choices.push(newChoice);
    renderChoices(currentEdit.data.choices);
};

const deleteChoice = (index) => {
    if (!currentEdit) return;
    currentEdit.data.choices.splice(index, 1);
    renderChoices(currentEdit.data.choices);
};

const saveEncEdit = () => {
    if (!currentEdit) return;
    
    currentEdit.data.name = encNameInput.value;
    currentEdit.data.text = encTextInput.value;
    currentEdit.data.charUrl = encCharUrlInput.value;
    currentEdit.data.trigger = encTriggerSelect.value;
    currentEdit.data.data = encDataInput.value;
    currentEdit.data.itemId = encItemIdManualCheck.checked ? encItemIdManual.value : encItemIdSelect.value;

    const newChoices = [];
    choicesDiv.querySelectorAll('.choice').forEach(choiceElement => {
        const choice = {
            id: choiceElement.querySelector('.choiceId').value, // **[추가]** ID 저장
            text: choiceElement.querySelector('.choiceText').value,
            resultText: choiceElement.querySelector('.choiceResultText').value,
            hpChange: parseInt(choiceElement.querySelector('.choiceHpChange').value) || 0,
            itemId: choiceElement.querySelector('.choiceItemIdSelect').value,
            itemQuantity: parseInt(choiceElement.querySelector('.choiceItemQuantity').value) || 1,
            trigger: choiceElement.querySelector('.choiceTrigger').value,
            data: choiceElement.querySelector('.choiceData').value
        };
        newChoices.push(choice);
    });
    currentEdit.data.choices = newChoices;
    
    hideModal(editModal);
    // Note: Changes are in local state. Must save map data to persist.
    addLogItem(`시스템: 조우 지점 (${currentEdit.x}, ${currentEdit.y}) 수정 완료. 맵 저장을 눌러 Firestore에 반영하세요.`, 'system');
    draw();
};

const deleteEncEdit = () => {
    if (!currentEdit) return;
    if (confirm(`조우 지점 (${currentEdit.x}, ${currentEdit.y})을 삭제하시겠습니까?`)) {
        encounterPoints = encounterPoints.filter(e => e !== currentEdit);
        document.getElementById('adminInfoRemainingEnc').textContent = encounterPoints.length;
        hideModal(editModal);
        // Note: Must save map data to persist deletion.
        addLogItem(`시스템: 조우 지점 (${currentEdit.x}, ${currentEdit.y}) 삭제 완료. 맵 저장을 눌러 Firestore에 반영하세요.`, 'system');
        draw();
    }
};


/* --- Encounter Player Logic (Uses Modal) --- */

const showEncounterModal = (enc, x, y) => {
    if (isEncountering) return;
    isEncountering = true;
    
    const encId = `${currentMapName}_${x}_${y}`;
    const usedChoices = player.encountered[encId]?.usedChoices || []; // **[수정]** 사용된 선택지 목록 로드

    // Reset UI
    encModalName.textContent = enc.data.name;
    encModalText.textContent = enc.data.text;
    encounterChoicesDiv.innerHTML = '';
    
    const charImg = document.getElementById('encCharImg');
    if (enc.data.charUrl) {
        charImg.src = enc.data.charUrl;
        charImg.style.display = 'block';
    } else {
        charImg.style.display = 'none';
    }

    // Process choices
    if (enc.data.choices && enc.data.choices.length > 0) {
        closeEncounterModalBtn.style.display = 'none';
        
        // Render choice buttons
        enc.data.choices.forEach((choice, index) => {
            const choiceId = choice.id || `choice_${index}`; 
            const button = document.createElement('button');
            button.textContent = choice.text;
            button.dataset.choiceId = choiceId;
            button.onclick = () => handleChoice(enc, choice, x, y);

            // **[수정]** 이미 사용된 선택지는 비활성화
            if (usedChoices.includes(choiceId)) {
                button.disabled = true;
                button.textContent += ' (선택 완료)'; 
            }

            encounterChoicesDiv.appendChild(button);
        });

    } else {
        // No choices: show 'Continue' button and handle default trigger
        closeEncounterModalBtn.style.display = 'block';
        closeEncounterModalBtn.onclick = () => handleDefaultTrigger(enc, x, y);
    }
    
    // Handle encounter item reward
    if (enc.data.itemId && !usedChoices.includes('reward')) { // Only grant if not previously rewarded (using 'reward' as a special choice ID)
        addLogItem(`시스템: 아이템 **${itemDefinitions[enc.data.itemId]?.name || enc.data.itemId}** 1개를 획득했습니다.`, 'item');
        addItemToPlayer(loggedInUserId, enc.data.itemId, 1);
        
        // Mark reward as taken
        const encId = `${currentMapName}_${x}_${y}`;
        if (!player.encountered[encId]) {
            player.encountered[encId] = { usedChoices: [] };
        }
        player.encountered[encId].usedChoices.push('reward');
        savePlayerState(); // Save after item acquisition
    }

    showModal(encounterModalBg);
};

const handleChoice = async (enc, choice, x, y) => {
    const choiceId = choice.id; 
    const encId = `${currentMapName}_${x}_${y}`;
    
    // **[수정]** 선택지 사용 기록 및 저장
    if (!player.encountered[encId]) {
        player.encountered[encId] = { usedChoices: [] };
    }
    if (!player.encountered[encId].usedChoices.includes(choiceId)) {
        player.encountered[encId].usedChoices.push(choiceId);
    }
    await savePlayerState(); 
    
    // 1. 결과 지문 표시
    addLogItem(`플레이어: ${choice.text}`, 'player', true);
    encModalText.textContent = choice.resultText;

    // 2. HP 변화 적용
    if (choice.hpChange !== 0) {
        player.hp = Math.min(MAX_HP, Math.max(0, player.hp + choice.hpChange));
        playerHPDisplay.textContent = player.hp;
        addLogItem(`시스템: HP가 ${choice.hpChange > 0 ? '+' : ''}${choice.hpChange}만큼 변경되었습니다. (현재 HP: ${player.hp})`, 'system');
        await savePlayerState();
    }

    // 3. 아이템 획득 적용
    if (choice.itemId && choice.itemQuantity > 0) {
        addLogItem(`시스템: 아이템 **${itemDefinitions[choice.itemId]?.name || choice.itemId}** ${choice.itemQuantity}개를 획득했습니다.`, 'item');
        addItemToPlayer(loggedInUserId, choice.itemId, choice.itemQuantity);
    }
    
    // 4. 트리거 실행
    if (choice.trigger && choice.trigger !== 'none') {
        await executeTrigger(choice.trigger, choice.data, x, y);
    }
    
    // 5. 선택지 버튼 숨기고 '계속 진행' 버튼 표시
    encounterChoicesDiv.innerHTML = '';
    closeEncounterModalBtn.style.display = 'block';
    closeEncounterModalBtn.onclick = () => closeEncounterModal();

    // Re-render choices if needed, but in this case, we just show 'Continue'.
};

const handleDefaultTrigger = async (enc, x, y) => {
     if (enc.data.trigger && enc.data.trigger !== 'none') {
        // Apply default reward/effect only if it hasn't been applied (using 'reward' as a special choice ID)
        const encId = `${currentMapName}_${x}_${y}`;
        const usedChoices = player.encountered[encId]?.usedChoices || [];
        if (!usedChoices.includes('default_trigger_applied')) {
            await executeTrigger(enc.data.trigger, enc.data.data, x, y);
            
            // Mark default trigger as applied
            if (!player.encountered[encId]) {
                player.encountered[encId] = { usedChoices: [] };
            }
            player.encountered[encId].usedChoices.push('default_trigger_applied');
            await savePlayerState(); 
        } else {
             addLogItem(`시스템: 이미 경험한 조우입니다.`, 'system');
        }
    }
    closeEncounterModal();
};

const executeTrigger = async (trigger, data, x, y) => {
    switch(trigger) {
        case 'sound':
            const sound = new Audio(data);
            sound.volume = bgmVolume.value;
            sound.play();
            addLogItem(`시스템: **[사운드 효과]** 재생 (${data})`, 'system');
            break;
        case 'image':
            // Simple image popup (can be implemented with another modal)
            alert(`이미지 팝업: ${data}`); 
            addLogItem(`시스템: **[이미지 팝업]** 표시 (${data})`, 'system');
            break;
        case 'map':
            addLogItem(`시스템: 맵 **${data}**로 이동합니다.`, 'system');
            await loadMapDataFromFirestore(data);
            // Reset player position to new map's start point
            player.x = mapData.startX || 0;
            player.y = mapData.startY || 0;
            await savePlayerState(); 
            break;
    }
};

const closeEncounterModal = () => {
    hideModal(encounterModalBg);
    isEncountering = false;
    // Check for transition point immediately after encounter
    checkForTransitionPoint();
    draw();
};

const checkEncounter = (x, y) => {
    const enc = getEncounterAt(x, y);
    if (enc && loggedInUserId && playerMode && !isEncountering) {
        // **[수정]** 방문 기록은 Encounter Modal에서만 처리
        // if (!player.encountered[`${currentMapName}_${x}_${y}`]?.visited) {
        //     player.encountered[`${currentMapName}_${x}_${y}`] = { visited: true, usedChoices: [] };
        //     savePlayerState();
        // }
        showEncounterModal(enc, x, y);
        return true;
    }
    return false;
};

/* --- Movement & Game Loop --- */

const movePlayer = async (dx, dy) => {
    if (!loggedInUserId || !playerMode || isMoving || isEncountering) return;
    
    isMoving = true;
    const newX = player.x + dx;
    const newY = player.y + dy;

    // Boundary check
    const maxX = canvas.width / GRID - 1;
    const maxY = canvas.height / GRID - 1;
    if (newX < 0 || newX > maxX || newY < 0 || newY > maxY) {
        isMoving = false;
        return;
    }

    // Impassable check
    if (getImpassableAt(newX, newY)) {
        addLogItem(`시스템: (${newX}, ${newY})는 지나갈 수 없는 구역입니다.`, 'system');
        isMoving = false;
        return;
    }

    // Update position
    player.x = newX;
    player.y = newY;
    
    await savePlayerState();
    draw();

    // Check for encounter
    const encounterTriggered = checkEncounter(newX, newY);
    
    if (!encounterTriggered) {
        // If no encounter, check for map transition immediately after moving
        checkForTransitionPoint();
    }
    
    isMoving = false;
};

const checkForTransitionPoint = async () => {
    if (player.x === mapData.transitionX && player.y === mapData.transitionY && mapData.nextMapName) {
        addLogItem(`시스템: 맵 **${mapData.nextMapName}**로 이동합니다.`, 'system');
        await loadMapDataFromFirestore(mapData.nextMapName);
        player.x = mapData.startX || 0;
        player.y = mapData.startY || 0;
        await savePlayerState();
    }
};

/* --- Firebase Interaction: Chat/Log --- */

const sendChatMessage = async (text) => {
    if (!loggedInUserId || !text.trim()) return;

    try {
        const isPlayerAdmin = loggedInUserId === ADMIN_EMAIL;
        await addDoc(collection(db, 'chat'), {
            text: text,
            nickname: document.getElementById('chatNickname').value || loggedInUserId,
            userId: loggedInUserId,
            isAdmin: isPlayerAdmin,
            timestamp: serverTimestamp()
        });
        document.getElementById('chatInput').value = '';
    } catch (e) {
        console.error("Error sending chat: ", e);
    }
};

const startChatListener = () => {
    if (chatUnsub) chatUnsub(); // Unsubscribe from previous listener

    const q = query(collection(db, 'chat'), orderBy('timestamp', 'desc'), limit(50));

    chatUnsub = onSnapshot(q, (snapshot) => {
        snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
                const data = change.doc.data();
                const type = data.isAdmin ? 'admin' : 'player';
                const displayText = `<strong>${data.nickname}:</strong> ${data.text}`;
                addLogItem(displayText, type, true);
            }
        });
    }, (error) => {
        console.error("Chat listener error: ", error);
    });
};

/* --- Firebase Interaction: Item Definitions (Admin) --- */

const saveItemDefinition = async (itemId, data) => {
    try {
        const itemRef = doc(db, 'items', itemId);
        await setDoc(itemRef, data);
        itemDefinitions[itemId] = data;
        addLogItem(`시스템: 아이템 **${data.name}** 등록/수정 완료.`, 'system');
        renderItemList(); // **[수정]** 아이템 목록 및 드롭다운 갱신
        updateItemDropdowns(); // **[수정]** 아이템 드롭다운 갱신
    } catch (e) {
        console.error("Error saving item definition: ", e);
        addLogItem(`시스템: 아이템 등록/수정 실패.`, 'system');
    }
};

const deleteItemDefinition = async (itemId) => {
    if (confirm(`아이템 **${itemDefinitions[itemId].name}**를 영구적으로 삭제하시겠습니까? (플레이어 인벤토리에서는 제거되지 않습니다.)`)) {
        try {
            await deleteDoc(doc(db, 'items', itemId));
            delete itemDefinitions[itemId];
            addLogItem(`시스템: 아이템 **${itemId}** 삭제 완료.`, 'system');
            renderItemList(); // **[수정]** 아이템 목록 및 드롭다운 갱신
            updateItemDropdowns(); // **[수정]** 아이템 드롭다운 갱신
        } catch (e) {
            console.error("Error deleting item definition: ", e);
            addLogItem(`시스템: 아이템 삭제 실패.`, 'system');
        }
    }
};

const fetchAllItems = async (shouldRender = false) => {
    try {
        const q = query(collection(db, 'items'), orderBy('name'));
        const snapshot = await getDocs(q);
        itemDefinitions = {}; // Reset before populating
        snapshot.forEach(doc => {
            itemDefinitions[doc.id] = doc.data();
        });
        
        if (shouldRender) {
            renderItemList(); // **[수정]** 아이템 목록 렌더링 및 드롭다운 갱신
        }
    } catch (e) {
        console.error("Error fetching all items: ", e);
        addLogItem(`시스템: 아이템 목록 로드 실패.`, 'system');
    }
};

// **[수정]** 아이템 목록을 렌더링하고 드롭다운을 갱신하는 함수
const renderItemList = () => {
    itemListDiv.innerHTML = ''; 

    if (Object.keys(itemDefinitions).length === 0) {
         itemListDiv.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">등록된 아이템 정의가 없습니다.</div>';
         return;
    }
    
    for (const itemId in itemDefinitions) {
        const item = itemDefinitions[itemId];
        const itemElement = document.createElement('div');
        itemElement.className = 'list-item';
        itemElement.innerHTML = `
            <span>${item.name} (${itemId})</span>
            <div>
                <button onclick="showEditItemModal('${itemId}')">수정</button>
                <button class="del" onclick="deleteItemDefinition('${itemId}')">삭제</button>
            </div>
        `;
        itemListDiv.appendChild(itemElement);
    }
    updateItemDropdowns(); // **[수정]** 아이템 리스트 렌더링 후 드롭다운 갱신 필수
};

// **[수정]** 아이템 드롭다운을 갱신하는 함수 (아이템 관리/사용자 관리/조우 수정에 사용)
const updateItemDropdowns = () => {
    const encItemIdSelect = document.getElementById('encItemIdSelect');
    const giveItemSelect = document.getElementById('giveItemSelect');

    [encItemIdSelect, giveItemSelect].forEach(select => {
        // 현재 선택된 값 저장
        const selectedValue = select.value;
        select.innerHTML = '';
        
        // Add default/placeholder option
        if (select.id === 'encItemIdSelect') {
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '획득 아이템 없음';
            select.appendChild(defaultOption);
        } else { // giveItemSelect
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '아이템 선택';
            select.appendChild(defaultOption);
        }

        for (const itemId in itemDefinitions) {
            const item = itemDefinitions[itemId];
            const option = document.createElement('option');
            option.value = itemId;
            option.textContent = `${item.name} (${itemId})`;
            select.appendChild(option);
        }
        
        // 이전에 선택된 값 복원 (있는 경우)
        if (select.querySelector(`option[value="${selectedValue}"]`)) {
            select.value = selectedValue;
        } else {
             select.value = ''; // 선택할 수 없으면 초기화
        }
    });
};


/* --- Firebase Interaction: User Management (Admin) --- */

const fetchAllUsers = async (shouldUpdateUI = false) => {
    try {
        const q = query(collection(db, 'players'), orderBy('id'));
        const snapshot = await getDocs(q);
        usersData = {};

        // 1. Fetch all user data
        snapshot.forEach(doc => {
            const data = doc.data();
            usersData[doc.id] = {
                ...data,
                id: doc.id,
                hp: data.hp || MAX_HP,
                currentMap: data.currentMap || 'default',
                x: data.x || 0,
                y: data.y || 0,
                charUrl: data.charUrl || '',
                inventory: data.inventory || {},
                encountered: data.encountered || {} // **[수정]** encountered 필드 로드
            };
        });

        // 2. Update UI if requested
        if (shouldUpdateUI) {
            renderUserList();
            updatePlayerSelectDropdowns();
            updatePlayerOnMapList();
        }
        
        return usersData;
    } catch (e) {
        console.error("Error fetching all users: ", e);
        addLogItem(`시스템: 사용자 목록 로드 실패.`, 'system');
        return {};
    }
};

const renderUserList = () => {
    const userListDiv = document.getElementById('userList');
    userListDiv.innerHTML = '';

    if (Object.keys(usersData).length === 0) {
         userListDiv.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">등록된 플레이어가 없습니다.</div>';
         return;
    }

    for (const userId in usersData) {
        const user = usersData[userId];
        const userElement = document.createElement('div');
        userElement.className = 'list-item';
        userElement.innerHTML = `
            <span style="flex: none; width: 100px;">${userId}</span>
            <span>HP: ${user.hp} | Map: ${user.currentMap}</span>
            <div>
                <button onclick="window.showUserInventory('${userId}')">아이템</button>
                <button class="del" onclick="deletePlayer('${userId}')">삭제</button>
            </div>
        `;
        userListDiv.appendChild(userElement);
    }
};

const updatePlayerSelectDropdowns = () => {
    const selects = [
        document.getElementById('selectPlayerId'),
        document.getElementById('selectPlayerIdMap'),
        document.getElementById('giveItemPlayerSelect')
    ];

    selects.forEach(select => {
        const selectedValue = select.value;
        select.innerHTML = '';
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '플레이어 선택';
        select.appendChild(defaultOption);

        for (const userId in usersData) {
            const option = document.createElement('option');
            option.value = userId;
            option.textContent = userId;
            select.appendChild(option);
        }
        
        // Restore previous selection
        if (select.querySelector(`option[value="${selectedValue}"]`)) {
            select.value = selectedValue;
        } else {
             select.value = '';
        }

        // Attach change listener for populating HP/Map fields
        if (select.id === 'selectPlayerId') {
            select.onchange = (e) => {
                const userId = e.target.value;
                if (userId && usersData[userId]) {
                    document.getElementById('playerHpInput').value = usersData[userId].hp;
                } else {
                    document.getElementById('playerHpInput').value = '';
                }
            };
        } else if (select.id === 'selectPlayerIdMap') {
            select.onchange = (e) => {
                const userId = e.target.value;
                if (userId && usersData[userId]) {
                    document.getElementById('playerMapInput').value = usersData[userId].currentMap;
                    document.getElementById('playerXInput').value = usersData[userId].x;
                    document.getElementById('playerYInput').value = usersData[userId].y;
                } else {
                    document.getElementById('playerMapInput').value = '';
                    document.getElementById('playerXInput').value = '';
                    document.getElementById('playerYInput').value = '';
                }
            };
        }
    });
};

const updatePlayerOnMapList = () => {
    const playerOnMapListDiv = document.getElementById('playerOnMapList');
    playerOnMapListDiv.innerHTML = '';

    const playersOnCurrentMap = Object.values(usersData).filter(u => u.currentMap === currentMapName);

    if (playersOnCurrentMap.length === 0) {
        playerOnMapListDiv.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">현재 맵 플레이어 없음</div>';
        return;
    }

    playersOnCurrentMap.forEach(user => {
        const item = document.createElement('div');
        item.className = 'player-on-map-item';
        item.innerHTML = `
            <strong>${user.id}</strong> (HP: ${user.hp})
            <small>Pos: (${user.x}, ${user.y})</small>
        `;
        playerOnMapListDiv.appendChild(item);
    });
};

/* --- Firebase Interaction: Inventory Management (Player) --- */

const addItemToPlayer = async (playerId, itemId, quantity = 1) => {
    if (!itemId) return;
    try {
        const playerRef = doc(db, 'players', playerId);
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerRef);
            if (!playerDoc.exists()) throw "Player does not exist!";
            
            const newInventory = playerDoc.data().inventory || {};
            newInventory[itemId] = (newInventory[itemId] || 0) + quantity;
            
            transaction.update(playerRef, { inventory: newInventory });

            // Update local state if the current player is affected
            if (playerId === loggedInUserId) {
                player.inventory = newInventory;
                renderPlayerInventory();
            }
        });
        fetchAllUsers(true); // Update Admin view
    } catch (e) {
        console.error("Error adding item to player: ", e);
        addLogItem(`시스템: [${playerId}]에게 아이템 추가 실패.`, 'system');
    }
};

const removeItemFromPlayer = async (playerId, itemId, quantity = 1) => {
    if (!itemId) return;
    try {
        const playerRef = doc(db, 'players', playerId);
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerRef);
            if (!playerDoc.exists()) throw "Player does not exist!";
            
            const newInventory = playerDoc.data().inventory || {};
            const currentQuantity = newInventory[itemId] || 0;
            
            if (currentQuantity <= quantity) {
                delete newInventory[itemId];
            } else {
                newInventory[itemId] = currentQuantity - quantity;
            }
            
            transaction.update(playerRef, { inventory: newInventory });

            // Update local state if the current player is affected
            if (playerId === loggedInUserId) {
                player.inventory = newInventory;
                renderPlayerInventory();
            }
        });
        fetchAllUsers(true); // Update Admin view
    } catch (e) {
        console.error("Error removing item from player: ", e);
        addLogItem(`시스템: [${playerId}]의 아이템 제거 실패.`, 'system');
    }
};

const renderPlayerInventory = () => {
    const inventoryListDiv = document.getElementById('inventoryList');
    inventoryListDiv.innerHTML = '';

    const items = Object.keys(player.inventory).filter(id => player.inventory[id] > 0);

    if (items.length === 0) {
        inventoryListDiv.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">인벤토리가 비어 있습니다.</div>';
        return;
    }

    items.forEach(itemId => {
        const quantity = player.inventory[itemId];
        const itemDef = itemDefinitions[itemId] || { name: '알 수 없는 아이템', imageUrl: '', description: '아이템 정의가 없습니다.' };
        
        const itemElement = document.createElement('div');
        itemElement.className = 'inventory-item';
        itemElement.dataset.itemId = itemId;
        itemElement.innerHTML = `
            <img src="${itemDef.imageUrl}" alt="${itemDef.name}" class="item-image" onerror="this.onerror=null;this.src='https://via.placeholder.com/40?text=?'" />
            <div>
                <span class="item-name">${itemDef.name} x${quantity}</span>
                <span class="item-desc">${itemDef.description}</span>
            </div>
        `;
        itemElement.addEventListener('click', () => showItemUseModal(itemId));
        inventoryListDiv.appendChild(itemElement);
    });
};

const showItemUseModal = (itemId) => {
    const itemDef = itemDefinitions[itemId];
    if (!itemDef) return;

    currentSelectedItem = itemId;

    document.getElementById('itemUseName').textContent = itemDef.name;
    document.getElementById('itemUseImage').src = itemDef.imageUrl;
    document.getElementById('itemUseImage').alt = itemDef.name;
    document.getElementById('itemUseDescription').textContent = itemDef.description;
    
    const useBtn = document.getElementById('useItemBtn');
    if (itemDef.hpRecover > 0) {
        useBtn.style.display = 'block';
        useBtn.textContent = `사용 (HP ${itemDef.hpRecover > 0 ? '+' : ''}${itemDef.hpRecover})`;
    } else {
        useBtn.style.display = 'none';
    }

    showModal(itemUseModalBg);
};

const useItem = async () => {
    const itemId = currentSelectedItem;
    const itemDef = itemDefinitions[itemId];

    if (!itemDef || player.inventory[itemId] <= 0 || itemDef.hpRecover <= 0) return;

    // 1. Remove item from inventory
    await removeItemFromPlayer(loggedInUserId, itemId, 1);
    addLogItem(`시스템: 아이템 **${itemDef.name}**을 사용했습니다.`, 'item');

    // 2. Apply effect
    player.hp = Math.min(MAX_HP, player.hp + itemDef.hpRecover);
    playerHPDisplay.textContent = player.hp;
    addLogItem(`시스템: HP가 +${itemDef.hpRecover}만큼 회복되었습니다. (현재 HP: ${player.hp})`, 'system');
    await savePlayerState();

    // 3. Close modal and re-render inventory
    hideModal(itemUseModalBg);
    renderPlayerInventory();
};

window.showUserInventory = (playerId) => {
    const user = usersData[playerId];
    if (!user) return;
    
    document.getElementById('inventoryModalTitle').textContent = `${playerId}의 인벤토리`;
    const listDiv = document.getElementById('inventoryModalList');
    listDiv.innerHTML = '';
    
    const items = Object.keys(user.inventory).filter(id => user.inventory[id] > 0);
    
    if (items.length === 0) {
        listDiv.innerHTML = '<div style="text-align: center; color: #aaa; font-size: 13px;">인벤토리가 비어 있습니다.</div>';
        showModal(document.getElementById('inventoryModal'));
        return;
    }

    items.forEach(itemId => {
        const quantity = user.inventory[itemId];
        const itemDef = itemDefinitions[itemId] || { name: '알 수 없는 아이템', description: '-' };
        
        const itemElement = document.createElement('div');
        itemElement.className = 'inventory-admin-item';
        itemElement.innerHTML = `
            <span>${itemDef.name} (${itemId}) x${quantity}</span>
            <div>
                <button onclick="window.removeAdminItem('${playerId}', '${itemId}')">제거(1)</button>
            </div>
        `;
        listDiv.appendChild(itemElement);
    });
    
    showModal(document.getElementById('inventoryModal'));
};

window.removeAdminItem = async (playerId, itemId) => {
    if (confirm(`${playerId}에게서 아이템 [${itemDefinitions[itemId]?.name || itemId}] 1개를 제거하시겠습니까?`)) {
        await removeItemFromPlayer(playerId, itemId, 1);
        // DB 업데이트 후 다시 인벤토리 팝업을 열어 갱신
        window.showUserInventory(playerId); 
        fetchAllUsers(true); 
    }
};

/* --- Event Listeners and Initializers --- */

const initEventListeners = () => {
    // Top Bar
    document.getElementById('playerLoginBtnTop').addEventListener('click', () => showModal(document.getElementById('playerLoginBox')));
    document.getElementById('adminBtn').addEventListener('click', () => showModal(document.getElementById('loginBox')));
    document.getElementById('loginBtn').addEventListener('click', adminLogin);
    document.getElementById('playerLoginBtnSubmit').addEventListener('click', playerLogin);
    document.getElementById('bgmToggleBtn').addEventListener('click', toggleBGM);
    document.getElementById('bgmVolume').addEventListener('input', (e) => bgmAudio.volume = parseFloat(e.target.value));
    
    // Chat
    document.getElementById('sendChatBtn').addEventListener('click', () => sendChatMessage(document.getElementById('chatInput').value));
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') { sendChatMessage(document.getElementById('chatInput').value); }
    });
    
    // Admin Tabs
    document.getElementById('mapTabBtn').addEventListener('click', () => switchTab('map'));
    document.getElementById('userTabBtn').addEventListener('click', () => switchTab('user'));
    document.getElementById('itemTabBtn').addEventListener('click', () => switchTab('item'));
    
    // Map Tab
    document.getElementById('saveMap').addEventListener('click', saveMapData);
    document.getElementById('reload').addEventListener('click', () => loadMapDataFromFirestore(currentMapName));
    document.getElementById('toggleGrid').addEventListener('click', toggleGrid);
    document.getElementById('toggleEncounter').addEventListener('click', toggleEncounterMode);
    document.getElementById('toggleImpassable').addEventListener('click', toggleImpassableMode);
    document.getElementById('setPlayerPos').addEventListener('click', setStartPoint);
    document.getElementById('setTransitionPos').addEventListener('click', setTransitionPoint);
    // **[수정]** 맵 초기화 버튼 이벤트 리스너
    initMapBtn.addEventListener('click', initCurrentMap); 

    // User Tab
    document.getElementById('addPlayerBtn').addEventListener('click', addPlayer);
    document.getElementById('updatePlayerStatusBtn').addEventListener('click', updatePlayerStatus);
    document.getElementById('updatePlayerMapBtn').addEventListener('click', updatePlayerMap);
    document.getElementById('giveItemBtn').addEventListener('click', giveItemToPlayer);

    // Item Tab
    document.getElementById('addItemBtn').addEventListener('click', addItemDefinition);
    
    // Encounter Edit Modal
    document.getElementById('addChoice').addEventListener('click', addChoice);
    document.getElementById('saveEncEdit').addEventListener('click', saveEncEdit);
    document.getElementById('deleteEncEdit').addEventListener('click', deleteEncEdit);
    document.getElementById('closeEncEdit').addEventListener('click', () => hideModal(editModal));
    document.getElementById('encItemIdManualCheck').addEventListener('change', (e) => {
        document.getElementById('encItemIdManual').style.display = e.target.checked ? 'block' : 'none';
    });

    // Player Modals
    // **[수정]** closeEncounterModalBtn의 이벤트는 handleChoice/handleDefaultTrigger에서 동적으로 설정됨.
    // document.getElementById('closeEncounterModal').addEventListener('click', closeEncounterModal);
    document.getElementById('closeItemUseModal').addEventListener('click', () => hideModal(itemUseModalBg));
    document.getElementById('useItemBtn').addEventListener('click', useItem);
    document.getElementById('closeInventoryModal').addEventListener('click', () => hideModal(document.getElementById('inventoryModal')));


    // Game Controls
    container.addEventListener('click', handleMapClick);
    
    // Drag/Drop Admin Panel
    makeAdminPanelDraggable();
    document.getElementById('minimizeBtn').addEventListener('click', toggleMinimize);

    // Movement
    document.addEventListener('keydown', handleMovement);
};

// ... (Functions like adminLogin, playerLogin, updateAdminUI, updatePlayerUI, switchTab, toggleBGM, toggleGrid, toggleEncounterMode, toggleImpassableMode, setStartPoint, setTransitionPoint, addPlayer, deletePlayer, updatePlayerStatus, updatePlayerMap, giveItemToPlayer, addItemDefinition, showEditItemModal, handleMapClick, handleMovement, makeAdminPanelDraggable, toggleMinimize are assumed to be defined as in the original code, but their implementation details are omitted here for brevity of listing functions not fully changed, except for the item related functions which have been enhanced) ...

// **[추가]** 아이템 정의 관련 함수 (Admin)
const addItemDefinition = async () => {
    const id = document.getElementById('newItemId').value.trim();
    const name = document.getElementById('newItemName').value.trim();
    const url = document.getElementById('newItemImageUrl').value.trim();
    const hpRecover = parseInt(document.getElementById('newItemHpRecover').value) || 0;
    const description = document.getElementById('newItemDescription').value.trim();

    if (!id || !name) {
        alert('아이템 ID와 이름을 입력해주세요.');
        return;
    }

    const data = { name, imageUrl: url, hpRecover, description };
    await saveItemDefinition(id, data);

    // Clear inputs
    document.getElementById('newItemId').value = '';
    document.getElementById('newItemName').value = '';
    document.getElementById('newItemImageUrl').value = '';
    document.getElementById('newItemHpRecover').value = 0;
    document.getElementById('newItemDescription').value = '';
};

// **[추가]** Item Edit Modal
const showEditItemModal = (itemId) => {
    // Implement item edit modal logic here if needed, or use the existing forms on the tab.
    alert(`아이템 [${itemId}] 수정은 아이템 관리 탭의 입력 필드를 사용하세요. 현재는 별도의 모달이 없습니다.`);
};


// **[추가]** Dummy implementations for assumed original functions (to ensure the provided code runs without reference errors, as the original full code was not visible)

const adminLogin = () => { 
    // Simplified logic for example
    if (document.getElementById('adminPw').value === ADMIN_DUMMY_PW) {
        auth.signInWithEmailAndPassword(ADMIN_EMAIL, ADMIN_DUMMY_PW)
            .catch(e => {
                console.error("Firebase Auth Error:", e);
                alert("로그인 실패: 비밀번호를 확인하거나 Firebase 설정이 올바른지 확인하세요.");
            });
    } else {
        alert("비밀번호가 틀렸습니다.");
    }
    hideModal(document.getElementById('loginBox'));
};

const playerLogin = async () => {
    const playerId = document.getElementById('playerIdInput').value.trim();
    if (!playerId) {
        alert('아이디를 입력해주세요.');
        return;
    }

    // Check if player exists in the fetched usersData
    if (!usersData[playerId]) {
        alert('등록되지 않은 플레이어 ID입니다.');
        return;
    }

    loggedInUserId = playerId;
    playerMode = true;
    currentMapName = usersData[playerId].currentMap || 'default';
    await loadPlayerState(playerId);
    updatePlayerUI(true);
    addLogItem(`시스템: 플레이어 **${playerId}** 로그인 성공.`, 'system');
    hideModal(document.getElementById('playerLoginBox'));
    startChatListener();
    renderPlayerInventory();
};


const updateAdminUI = (isAdmin) => {
    adminMode = isAdmin;
    if (isAdmin) {
        adminPanel.style.display = 'block';
        document.getElementById('adminRightInfo').style.display = 'flex';
        document.getElementById('playerContent').style.display = 'none';
    } else {
        adminPanel.style.display = 'none';
        document.getElementById('adminRightInfo').style.display = 'none';
        // If player is logged in, show player content
        if (loggedInUserId) {
             document.getElementById('playerContent').style.display = 'flex';
        }
    }
};

const updatePlayerUI = (isPlayer) => {
    playerMode = isPlayer;
    if (isPlayer) {
        document.getElementById('logChatPanel').style.display = 'flex';
        document.getElementById('statusInventoryPanel').style.display = 'flex';
        document.getElementById('playerContent').style.display = 'flex';
        document.getElementById('chatInput').disabled = false;
        document.getElementById('sendChatBtn').disabled = false;
        playerHPDisplay.textContent = player.hp;
        // Start game loop if not already running
        if (!animationFrameId) {
             animationFrameId = requestAnimationFrame(draw);
        }
    } else {
        document.getElementById('playerContent').style.display = 'none';
        if (!adminMode) {
             document.getElementById('logChatPanel').style.display = 'none';
             document.getElementById('statusInventoryPanel').style.display = 'none';
        }
        loggedInUserId = null;
        if (chatUnsub) chatUnsub();
    }
};

const switchTab = (tabId) => {
    document.querySelectorAll('.admin-tab-content').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.admin-tabs button').forEach(el => el.classList.remove('active'));
    document.getElementById(`${tabId}TabContent`).classList.add('active');
    document.getElementById(`${tabId}TabBtn`).classList.add('active');

    // Load data specific to the tab
    if (tabId === 'user') {
        fetchAllUsers(true);
    } else if (tabId === 'item') {
        fetchAllItems(true); // Ensures item list and dropdowns are updated
    }
};

const toggleBGM = () => {
    if (bgmAudio.paused) {
        bgmAudio.play().catch(e => console.log("BGM Play failed:", e));
        document.getElementById('bgmToggleBtn').textContent = 'PAUSE';
    } else {
        bgmAudio.pause();
        document.getElementById('bgmToggleBtn').textContent = 'PLAY';
    }
};

const toggleGrid = () => {
    isGridMode = !isGridMode;
    document.getElementById('toggleGrid').classList.toggle('active', isGridMode);
    draw();
};

const toggleEncounterMode = () => {
    isEncounterMode = !isEncounterMode;
    isImpassableMode = false;
    document.getElementById('toggleEncounter').classList.toggle('active', isEncounterMode);
    document.getElementById('toggleImpassable').classList.remove('active');
};

const toggleImpassableMode = () => {
    isImpassableMode = !isImpassableMode;
    isEncounterMode = false;
    document.getElementById('toggleImpassable').classList.toggle('active', isImpassableMode);
    document.getElementById('toggleEncounter').classList.remove('active');
};

const setStartPoint = () => {
    mapData.startX = parseInt(startXInput.value) || 0;
    mapData.startY = parseInt(startYInput.value) || 0;
    draw();
    addLogItem(`시스템: 시작 좌표를 (${mapData.startX}, ${mapData.startY})로 설정했습니다.`, 'system');
};

const setTransitionPoint = () => {
    mapData.transitionX = transitionXInput.value ? parseInt(transitionXInput.value) : null;
    mapData.transitionY = transitionYInput.value ? parseInt(transitionYInput.value) : null;
    draw();
    if (mapData.transitionX !== null) {
        addLogItem(`시스템: 맵 이동 좌표를 (${mapData.transitionX}, ${mapData.transitionY})로 설정했습니다.`, 'system');
    } else {
        addLogItem(`시스템: 맵 이동 좌표를 해제했습니다.`, 'system');
    }
};

const handleMapClick = (e) => {
    if (!adminMode) return;
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / GRID);
    const y = Math.floor((e.clientY - rect.top) / GRID);

    const existingEnc = getEncounterAt(x, y);
    const existingImp = getImpassableAt(x, y);

    if (isEncounterMode) {
        if (existingImp) {
            alert('이곳은 이동 제한 구역입니다. 제한 구역을 먼저 삭제해주세요.');
            return;
        }
        if (existingEnc) {
            openEditModal(existingEnc);
        } else {
            addEncounter(x, y);
        }
    } else if (isImpassableMode) {
        if (existingEnc) {
            alert('이곳은 조우 지점입니다. 조우 지점을 먼저 삭제해주세요.');
            return;
        }
        if (existingImp) {
            impassablePoints = impassablePoints.filter(p => p !== existingImp);
            addLogItem(`시스템: 제한 구역 (${x}, ${y})을 삭제했습니다. 맵 저장을 눌러 Firestore에 반영하세요.`, 'system');
        } else {
            impassablePoints.push({ x, y });
            addLogItem(`시스템: 제한 구역 (${x}, ${y})을 추가했습니다. 맵 저장을 눌러 Firestore에 반영하세요.`, 'system');
        }
        draw();
    } else if (adminMode) {
        // Edit mode (Click on existing points to open editor)
        if (existingEnc) {
            openEditModal(existingEnc);
        } else if (existingImp) {
            alert(`제한 구역 (${x}, ${y}) - 삭제하려면 '제한 추가' 모드에서 클릭하세요.`);
        } else {
            addLogItem(`시스템: 빈 구역 (${x}, ${y}).`, 'system');
        }
    }
};

const handleMovement = (e) => {
    if (!loggedInUserId || isEncountering) return;

    let dx = 0;
    let dy = 0;
    switch (e.key) {
        case 'ArrowUp':
        case 'w':
            dy = -1;
            break;
        case 'ArrowDown':
        case 's':
            dy = 1;
            break;
        case 'ArrowLeft':
        case 'a':
            dx = -1;
            break;
        case 'ArrowRight':
        case 'd':
            dx = 1;
            break;
        default:
            return;
    }
    e.preventDefault();
    movePlayer(dx, dy);
};

const makeAdminPanelDraggable = () => {
    let isDragging = false;
    let offsetX, offsetY;
    const header = adminPanel.querySelector('h4');

    header.addEventListener('mousedown', (e) => {
        if (adminPanel.classList.contains('minimized')) return;
        isDragging = true;
        offsetX = e.clientX - adminPanel.getBoundingClientRect().left;
        offsetY = e.clientY - adminPanel.getBoundingClientRect().top;
        adminPanel.style.cursor = 'grabbing';
        adminPanel.style.transition = 'none';
        e.preventDefault(); 
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        adminPanel.style.left = (e.clientX - offsetX) + 'px';
        adminPanel.style.top = (e.clientY - offsetY) + 'px';
        adminPanel.style.right = 'auto'; // Disable right lock
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        adminPanel.style.cursor = 'grab';
        adminPanel.style.transition = 'width 0.3s, height 0.3s, padding 0.3s, overflow 0.3s';
    });
};

const toggleMinimize = () => {
    adminPanel.classList.toggle('minimized');
};

const addPlayer = async () => {
    const id = document.getElementById('newUserId').value.trim();
    const charUrl = document.getElementById('newUserCharUrl').value.trim();

    if (!id) {
        alert('플레이어 ID를 입력해주세요.');
        return;
    }
    
    if (usersData[id]) {
        alert('이미 존재하는 ID입니다.');
        return;
    }

    try {
        const playerRef = doc(db, 'players', id);
        const newPlayer = {
            id: id,
            hp: MAX_HP,
            currentMap: 'default',
            x: 0,
            y: 0,
            charUrl: charUrl,
            inventory: {},
            encountered: {}
        };
        await setDoc(playerRef, newPlayer);
        addLogItem(`시스템: 플레이어 **${id}** 생성 완료.`, 'system');
        document.getElementById('newUserId').value = '';
        document.getElementById('newUserCharUrl').value = '';
        await fetchAllUsers(true);
    } catch (e) {
        console.error("Error adding player: ", e);
        addLogItem(`시스템: 플레이어 생성 실패.`, 'system');
    }
};

const deletePlayer = async (playerId) => {
    if (confirm(`플레이어 **${playerId}**의 계정을 영구적으로 삭제하시겠습니까?`)) {
        try {
            await deleteDoc(doc(db, 'players', playerId));
            addLogItem(`시스템: 플레이어 **${playerId}** 삭제 완료.`, 'system');
            await fetchAllUsers(true);
            // If the deleted player was logged in, log them out
            if (loggedInUserId === playerId) {
                 await auth.signOut();
                 updatePlayerUI(false);
            }
        } catch (e) {
            console.error("Error deleting player: ", e);
            addLogItem(`시스템: 플레이어 삭제 실패.`, 'system');
        }
    }
};

const updatePlayerStatus = async () => {
    const playerId = document.getElementById('selectPlayerId').value;
    const hp = parseInt(document.getElementById('playerHpInput').value);

    if (!playerId || isNaN(hp)) {
        alert('플레이어와 HP를 올바르게 선택/입력해주세요.');
        return;
    }
    
    try {
        const playerRef = doc(db, 'players', playerId);
        await updateDoc(playerRef, { hp: Math.min(MAX_HP, Math.max(0, hp)) });
        
        // Update local state
        if (usersData[playerId]) usersData[playerId].hp = hp;
        if (loggedInUserId === playerId) {
            player.hp = hp;
            playerHPDisplay.textContent = hp;
        }

        addLogItem(`시스템: 플레이어 **${playerId}** 상태(HP: ${hp}) 업데이트 완료.`, 'system');
        await fetchAllUsers(true);
    } catch (e) {
        console.error("Error updating player status: ", e);
        addLogItem(`시스템: 플레이어 상태 업데이트 실패.`, 'system');
    }
};

const updatePlayerMap = async () => {
    const playerId = document.getElementById('selectPlayerIdMap').value;
    const map = document.getElementById('playerMapInput').value.trim();
    const x = parseInt(document.getElementById('playerXInput').value);
    const y = parseInt(document.getElementById('playerYInput').value);

    if (!playerId || !map || isNaN(x) || isNaN(y)) {
        alert('플레이어, 맵 이름, 좌표를 올바르게 선택/입력해주세요.');
        return;
    }
    
    try {
        const playerRef = doc(db, 'players', playerId);
        await updateDoc(playerRef, { currentMap: map, x, y });

        // Update local state
        if (usersData[playerId]) {
            usersData[playerId].currentMap = map;
            usersData[playerId].x = x;
            usersData[playerId].y = y;
        }
        if (loggedInUserId === playerId) {
            await loadMapDataFromFirestore(map);
            player.x = x;
            player.y = y;
        }

        addLogItem(`시스템: 플레이어 **${playerId}** 위치(${map}, ${x}, ${y}) 업데이트 완료.`, 'system');
        await fetchAllUsers(true);
    } catch (e) {
        console.error("Error updating player map: ", e);
        addLogItem(`시스템: 플레이어 위치 업데이트 실패.`, 'system');
    }
};

const giveItemToPlayer = async () => {
    const playerId = document.getElementById('giveItemPlayerSelect').value;
    const itemId = document.getElementById('giveItemSelect').value;
    
    if (!playerId || !itemId) {
        alert('플레이어와 아이템을 선택해주세요.');
        return;
    }

    await addItemToPlayer(playerId, itemId, 1);
    addLogItem(`시스템: 플레이어 **${playerId}**에게 아이템 **${itemDefinitions[itemId]?.name || itemId}** 1개 지급 완료.`, 'system');
};

// Expose functions to the global scope for onclick handlers in dynamically generated HTML
window.deleteMap = deleteMap;
window.showUserInventory = showUserInventory;
window.removeAdminItem = removeAdminItem;


// Initialization Sequence
initEventListeners(); 

onAuthStateChanged(auth, (user) => {
    if (user && user.email === ADMIN_EMAIL) {
        updateAdminUI(true);
        addLogItem(`시스템: 관리자 (${user.email}) 로그인 성공.`, 'system');
    } else {
        if (!loggedInUserId) {
            updateAdminUI(false);
            updatePlayerUI(false);
        } else {
            updateAdminUI(false); 
        }
    }
});

const initialMap = localStorage.getItem('currentMap') || 'default';

Promise.all([
    fetchAllUsers(false),
    fetchAllItems(true), // **[수정]** 아이템 로드 후 renderItemList (목록 및 드롭다운 갱신)
    loadMapDataFromFirestore(initialMap).then(loaded => {
        if (!loaded) {
            mapNameInput.value = 'default';
            currentMapName = 'default';
            addLogItem(`시스템: 맵 데이터가 없어 **[default]** 맵으로 초기화.`, 'system');
        }
    }),
    reloadMapList()
]).then(() => {
    startXInput.value = player.x;
    startYInput.value = player.y; 
    draw();

    const savedPlayerId = localStorage.getItem('playerId');
    if (savedPlayerId && usersData[savedPlayerId]) {
         document.getElementById('playerIdInput').value = savedPlayerId;
         // Auto-login only if not in admin mode
         if (!adminMode) {
              playerLogin(); 
         }
    }
});
</script>
</body>
</html>
